<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AirCloud 日常</title>
  <icon>https://www.gravatar.com/avatar/2f58f77d5b516b291563686ed164bd51</icon>
  <subtitle>sometimes code, sometimes design</subtitle>
  <link href="https://z4ynadmin.github.io/atom.xml" rel="self"/>
  
  <link href="https://z4ynadmin.github.io/"/>
  <updated>2022-11-04T07:11:09.554Z</updated>
  <id>https://z4ynadmin.github.io/</id>
  
  <author>
    <name>Xiaotao Nie</name>
    <email>onlythen@yeah.net</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读完 type-challenges，我总结了如下常用的内容</title>
    <link href="https://z4ynadmin.github.io/2022/07/30/type-challenges/"/>
    <id>https://z4ynadmin.github.io/2022/07/30/type-challenges/</id>
    <published>2022-07-30T07:39:38.000Z</published>
    <updated>2022-11-04T07:11:09.554Z</updated>
    
    <content type="html"><![CDATA[<p>近期用了一定时间通读了 <a href="https://github.com/type-challenges/type-challenges">type-challenges</a>，感慨 Typescript 也可以写的如此复杂之余，也出于以下几个原因，对题目做了整理，形成本文：</p><ul><li>type-challenges 整体题目较多，而且很多时候我们只是学习为主，并不是以“做题”为目的，这样我们在列表-问题-答案列表-答案详情中跳来跳去很麻烦，也很难甄别优质解答。</li><li>type-challenges 仓库中某些题目，实属偏门，可能对于大多数业务开发来说，永远也用不到，投入时间在这部分，ROI 就会非常低。</li><li>type-challenges 有些题目比较类似，但是却放到了不同的地方，甚至难度不同，笔者认为结合起来一起看可能更高效。</li></ul><p>因此，本文对笔者认为重要的、有业务使用场景或者可以给我们以很大启发的题目进行罗列和解析，同时规避了一些复杂度很高，但实际大多数人用不到的题目（比如 Typescript 实现 JSON 解析），对于普通的 Typescript 开发者而言，看完本文的题目就基本能够以一个比较小的代价掌握 type-challenges 中贴近日常开发和业务的部分。</p><blockquote><p>感谢 type-challenges 仓库的贡献者们</p></blockquote><h2 id="Typescript-内置工具函数"><a href="#Typescript-内置工具函数" class="headerlink" title="Typescript 内置工具函数"></a>Typescript 内置工具函数</h2><p>实际上，Typescript 自身除了定义类型以外，自己内置了很多非常有用的工具函数，这部分是我们日常 Typescript 开发应当必须掌握，信手拈来的，我建议如果对这部分不熟悉的话，先多读几遍这部分。</p><p>这部分内容，可以在<a href="https://www.typescriptlang.org/docs/handbook/utility-types.html">这里</a> 了解，也可以在自己的项目中，点进 <code>node_modules/typescript/lib/lib.es5.d.ts</code> 直接了解，注释比较详尽。</p><blockquote><p>实际上，type-challenges 的一部分简单和中等的题目就是实现这些内置工具函数的二次实现，这部分内容我在本文基本没有重复罗列，但是建议大家去阅读官方实现，一般来说也都比较短小，容易理解</p></blockquote><h2 id="type-challenges-部分重点题目"><a href="#type-challenges-部分重点题目" class="headerlink" title="type-challenges 部分重点题目"></a>type-challenges 部分重点题目</h2><h3 id="数组第一个元素"><a href="#数组第一个元素" class="headerlink" title="数组第一个元素"></a>数组第一个元素</h3><p><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00014-easy-first/README.md">原文地址</a></p><p>使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">type</span> head1 = First&lt;arr1&gt; <span class="comment">// expected to be &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure><p>实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> First&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [infer first, ...any[]]</span><br><span class="line">  ? first</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><p>除了本题目，还有许多其他类似的实现：：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组最后一个元素:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Last&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [...any, infer L] ? L : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop：</span></span><br><span class="line"><span class="comment">// type arr1 = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span></span><br><span class="line"><span class="comment">// type re1 = Pop&lt;arr1&gt; // expected to be [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Pop&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> [...infer P, infer R] ? P : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push:</span></span><br><span class="line"><span class="comment">// type Result = Push&lt;[1, 2], &#x27;3&#x27;&gt; // [1, 2, &#x27;3&#x27;]</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Push&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], U&gt; = [...T, U];</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnShift:</span></span><br><span class="line"><span class="comment">// type Result = UnShift&lt;[1, 2], 0&gt; // [0, 1, 2,]</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> UnShift&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], U&gt; = [U, ...T];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shift:</span></span><br><span class="line"><span class="comment">// type Result = Shift&lt;[3, 2, 1]&gt; // [2, 1]</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Shift&lt;T&gt; = T <span class="keyword">extends</span> [infer F,... infer R] ? R : <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Concat：</span></span><br><span class="line"><span class="comment">// type Result = Concat &lt;[1], [2]&gt; // expected to be [1, 2]</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Concat &lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], V <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = [...T, ...V];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reverse:</span></span><br><span class="line"><span class="comment">// type b = Reverse&lt;[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&gt; // [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Reverse&lt;T&gt; = T <span class="keyword">extends</span> [infer Head, ...infer Rest] ? [...Reverse&lt;Rest&gt;, Head] : T</span><br><span class="line"></span><br><span class="line"><span class="comment">// FilterOut：</span></span><br><span class="line"><span class="comment">// type Filtered = FilterOut&lt;[1, 2, null, 3], null&gt; // [1, 2, 3]</span></span><br><span class="line"><span class="keyword">type</span> Filtered = FilterOut&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">null</span>, <span class="number">3</span>], <span class="literal">null</span>&gt; <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> FilterOut&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], F&gt; = </span><br><span class="line">  T <span class="keyword">extends</span> [infer First, ...infer Rest] </span><br><span class="line">    ? First <span class="keyword">extends</span> F </span><br><span class="line">      ? FilterOut&lt;Rest, F&gt; </span><br><span class="line">      : [First, ...FilterOut&lt;Rest, F&gt;] </span><br><span class="line">    : []</span><br></pre></td></tr></table></figure><p>技巧提示：</p><ul><li>通过 extends 加三目运算符，完成条件判断。</li><li>通过类似 <code>infer first, ...any[]</code> 或者 <code>[infer First, ...infer Rest]</code> 这种方式来展开数组类型。</li><li>另外我们还可以使用 <code>[...T, U]</code> 来扩充数组的类型定义。</li></ul><h3 id="Tuple-to-Union"><a href="#Tuple-to-Union" class="headerlink" title="Tuple to Union"></a>Tuple to Union</h3><p><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00010-medium-tuple-to-union/README.md">原文地址</a></p><p>使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Arr = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]</span><br><span class="line"><span class="keyword">type</span> Test = TupleToUnion&lt;Arr&gt; <span class="comment">// expected to be &#x27;1&#x27; | &#x27;2&#x27; | &#x27;3&#x27;</span></span><br></pre></td></tr></table></figure><p>实现比较简单：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> TupleToUnion&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T[<span class="built_in">number</span>];</span><br></pre></td></tr></table></figure><p>技巧提示：</p><ul><li><code>T[number]</code> 这种语法可以比较方便地实现 Tuple to Union</li></ul><h3 id="Deep-Readonly"><a href="#Deep-Readonly" class="headerlink" title="Deep Readonly"></a>Deep Readonly</h3><p><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00009-medium-deep-readonly/README.md#deep-readonly----">原文地址</a></p><p>使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X = &#123; </span><br><span class="line">  <span class="attr">x</span>: &#123; </span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">    <span class="attr">b</span>: <span class="string">&#x27;hi&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">y</span>: <span class="string">&#x27;hey&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Expected = &#123; </span><br><span class="line">  <span class="keyword">readonly</span> x: &#123; </span><br><span class="line">    <span class="keyword">readonly</span> a: <span class="number">1</span></span><br><span class="line">    <span class="keyword">readonly</span> b: <span class="string">&#x27;hi&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">readonly</span> y: <span class="string">&#x27;hey&#x27;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Todo = DeepReadonly&lt;X&gt; <span class="comment">// should be same as `Expected`</span></span><br></pre></td></tr></table></figure><p>实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> DeepReadonly&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: keyof T[P] <span class="keyword">extends</span> <span class="built_in">never</span> ? T[P] : DeepReadonly&lt;T[P]&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>技巧提示：</p><ul><li>通过 <code>keyof T[P] extends never</code> 这种方式判断是否有子属性，可以完成深度遍历</li></ul><h3 id="Merge-以及其他-interface-相关"><a href="#Merge-以及其他-interface-相关" class="headerlink" title="Merge 以及其他 interface 相关"></a>Merge 以及其他 interface 相关</h3><p><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00599-medium-merge/README.md">原文地址</a></p><p>使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> foo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> coo = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  sex: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result = Merge&lt;foo,coo&gt;; <span class="comment">// expected to be &#123;name: string, age: number, sex: string&#125;</span></span><br></pre></td></tr></table></figure><p>Merge 的功能和 typescript 提供的很多内置功能函数很像，这个题目实现的方式很多，我这里给出一个比较简洁的方式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Merge&lt;T, U&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> Exclude&lt;keyof T, keyof U&gt;]: T[P];</span><br><span class="line">&#125; &amp; &#123;</span><br><span class="line">  [G <span class="keyword">in</span> keyof U]: U[G];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类似 Merge，我们在再给出一些其他的简单的类似 type 相关的操作</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Diff：选出两个类型中不同属性：</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Diff&lt;T, U&gt; = Omit&lt;T &amp; U, keyof T &amp; keyof U&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PickByType：按照类型选择</span></span><br><span class="line"><span class="comment">// type OnlyBoolean = PickByType&lt;&#123;</span></span><br><span class="line"><span class="comment">//   name: string</span></span><br><span class="line"><span class="comment">//   count: number</span></span><br><span class="line"><span class="comment">//   isReadonly: boolean</span></span><br><span class="line"><span class="comment">//   isEnable: boolean</span></span><br><span class="line"><span class="comment">// &#125;, boolean&gt; // &#123; isReadonly: boolean; isEnable: boolean; &#125;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> PickByType&lt;T, U&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T <span class="keyword">as</span> T[K] <span class="keyword">extends</span> U ? K : <span class="built_in">never</span>]: T[K];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RequiredByKeys：按照 key 来设置成 Require</span></span><br><span class="line"><span class="comment">// interface User &#123;</span></span><br><span class="line"><span class="comment">//   name?: string</span></span><br><span class="line"><span class="comment">//   age?: number</span></span><br><span class="line"><span class="comment">//   address?: string</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// type UserRequiredName = RequiredByKeys&lt;User, &#x27;name&#x27;&gt; // &#123; name: string; age?: number; address?: string &#125;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> RequiredByKeys&lt;T, K = keyof T&gt; = SimpleMerge&lt;</span><br><span class="line">  Partial&lt;Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;&gt;,</span><br><span class="line">  Required&lt;Pick&lt;T, Extract&lt;keyof T, K&gt;&gt;&gt;</span><br><span class="line">  <span class="comment">// **可以看一下 Required 的写法，能学到一点新的东西</span></span><br><span class="line">&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mutable</span></span><br><span class="line"><span class="comment">// interface Todo &#123;</span></span><br><span class="line"><span class="comment">//   readonly title: string</span></span><br><span class="line"><span class="comment">//   readonly description: string</span></span><br><span class="line"><span class="comment">//   readonly completed: boolean</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// type MutableTodo = Mutable&lt;Todo&gt; // &#123; title: string; description: string; completed: boolean; &#125;</span></span><br><span class="line"><span class="comment">// your answers</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Mutable&lt;T&gt; = &#123;</span><br><span class="line">  -<span class="keyword">readonly</span> [K <span class="keyword">in</span> keyof T]: T[K]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get Required</span></span><br><span class="line"><span class="comment">// type I = GetRequired&lt;&#123; foo: number, bar?: string &#125;&gt; // expected to be &#123; foo: number &#125;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> GetRequired&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> T[P] <span class="keyword">extends</span> Required&lt;T&gt;[P] ? P : <span class="built_in">never</span>]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> RequiredKeys&lt;T&gt; = keyof GetRequired&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get Optional</span></span><br><span class="line"><span class="comment">// type I = GetOptional&lt;&#123; foo: number, bar?: string &#125;&gt; // expected to be &#123; bar?: string &#125;</span></span><br><span class="line"><span class="comment">// https://github.com/type-challenges/type-challenges/blob/main/questions/00059-hard-get-optional/README.md</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> GetOptional&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> T[P] <span class="keyword">extends</span> Required&lt;T&gt;[P] ? <span class="built_in">never</span> : P]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> OptionalKeys&lt;T&gt; = keyof GetOptional&lt;T&gt;</span><br></pre></td></tr></table></figure><p>一些技巧提示：</p><ul><li>通过组合 Typescript 内置的功能函数，我们可以完成很多复杂的业务需求。</li><li>通过 <code>-readonly</code> 来减去修饰符。</li><li>通过 <code>[P in keyof T]-?: T[P];</code> 这种方式来减去可选修饰符（Typescript 内置的 Required 就是这么实现的）。</li><li>通过 <code>K in keyof T as T[K]</code> 获取一个属性的类型，结合 extends 做条件判断。</li></ul><h3 id="TrimLeft-以及字符串相关"><a href="#TrimLeft-以及字符串相关" class="headerlink" title="TrimLeft 以及字符串相关"></a>TrimLeft 以及字符串相关</h3><p><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00106-medium-trimleft/README.md">原文地址</a></p><p>使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> trimed = TrimLeft&lt;<span class="string">&#x27;  Hello World  &#x27;</span>&gt; <span class="comment">// expected to be &#x27;Hello World  &#x27;</span></span><br></pre></td></tr></table></figure><p>实际上字符串操作在 Typescript 中应该用的并不是很多，而这也是 Typescript 比较后面（4.0+）才逐渐完善的功能。<br>这个题目的解答：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Space = <span class="string">&quot; &quot;</span> | <span class="string">&quot;\n&quot;</span> | <span class="string">&quot;\t&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> TrimLeft&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;Space&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">  ? TrimLeft&lt;Rest&gt;</span><br><span class="line">  : S;</span><br></pre></td></tr></table></figure><p>实际上，我们如果知道可以这样写，还可以实现很多的类似的方式，比如可以很方便地实现 <code>Trim</code> 和 <code>TrimRight</code> （由于相似度非常高，这两个不再罗列答案），以及 <code>Replace</code>、<code>ReplaceAll</code>、<code>DropChar</code> 等，甚至还可以比较方便地实现类型转换，如 <code>ParseInt</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Replace</span></span><br><span class="line"><span class="comment">// type replaced = Replace&lt;&#x27;types are fun!&#x27;, &#x27;fun&#x27;, &#x27;awesome&#x27;&gt; // expected to be &#x27;types are awesome!&#x27;</span></span><br><span class="line"><span class="comment">// https://github.com/type-challenges/type-challenges/blob/main/questions/00116-medium-replace/README.md</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Replace&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  From <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  To <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = From <span class="keyword">extends</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  ? S</span><br><span class="line">  : S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Left&#125;</span><span class="subst">$&#123;From&#125;</span><span class="subst">$&#123;infer Right&#125;</span>`</span></span><br><span class="line">  ? <span class="string">`<span class="subst">$&#123;Left&#125;</span><span class="subst">$&#123;To&#125;</span><span class="subst">$&#123;Right&#125;</span>`</span></span><br><span class="line">  : S;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 近似 Replace，替换全部</span></span><br><span class="line"><span class="comment">// type replaced = ReplaceAll&lt;&#x27;t y p e s&#x27;, &#x27; &#x27;, &#x27;&#x27;&gt; // expected to be &#x27;types&#x27;</span></span><br><span class="line"><span class="comment">// https://github.com/type-challenges/type-challenges/blob/main/questions/00119-medium-replaceall/README.md</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> ReplaceAll&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  From <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  To <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = From <span class="keyword">extends</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  ? S</span><br><span class="line">  : S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Left&#125;</span><span class="subst">$&#123;From&#125;</span><span class="subst">$&#123;infer Right&#125;</span>`</span></span><br><span class="line">  ? <span class="string">`<span class="subst">$&#123;Left&#125;</span><span class="subst">$&#123;To&#125;</span><span class="subst">$&#123;ReplaceAll&lt;<span class="string">`<span class="subst">$&#123;Right&#125;</span>`</span>, From, To&gt;&#125;</span>`</span></span><br><span class="line">  : S;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Drop Char</span></span><br><span class="line"><span class="comment">// 和上面的比较类似</span></span><br><span class="line"><span class="comment">// type Butterfly = DropChar&lt;&#x27; b u t t e r f l y ! &#x27;, &#x27; &#x27;&gt; // &#x27;butterfly!&#x27;</span></span><br><span class="line"><span class="comment">// https://github.com/type-challenges/type-challenges/blob/main/questions/02070-medium-drop-char/README.md</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> DropChar&lt;S, C&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer H&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">  ? H <span class="keyword">extends</span> C</span><br><span class="line">    ? <span class="string">`<span class="subst">$&#123;DropChar&lt;R, C&gt;&#125;</span>`</span></span><br><span class="line">    : <span class="string">`<span class="subst">$&#123;H&#125;</span><span class="subst">$&#123;DropChar&lt;R, C&gt;&#125;</span>`</span></span><br><span class="line">  : <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ParseInt：字符串转数字：</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> ParseInt&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = T <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Digit <span class="keyword">extends</span> <span class="built_in">number</span>&#125;</span>`</span> ? Digit : <span class="built_in">never</span></span><br></pre></td></tr></table></figure><p>另外，基于操作字符串的能力，我们还可以实现更多，比如：</p><ul><li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00531-medium-string-to-union/README.md">StringToUnion</a> 字符串转联合类型，<code>123</code> -&gt; <code>&quot;1&quot; | &quot;2&quot; | &quot;3&quot;</code></li><li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00612-medium-kebabcase/README.md">KebabCase</a> 字符串格式转换，<code>FooBarBaz -&gt; foo-bar-baz</code></li></ul><p>等等，这些笔者没有列举具体实现，是因为认为大部分开发中用的还是不多的，如果你直接一眼就能想出方案，可能也不用去看了。</p><h3 id="Append-Argument"><a href="#Append-Argument" class="headerlink" title="Append Argument"></a>Append Argument</h3><p><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00191-medium-append-argument/README.md">原文地址</a></p><p>使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fn = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result = AppendArgument&lt;Fn, <span class="built_in">boolean</span>&gt; </span><br><span class="line"><span class="comment">// expected be (a: number, b: string, x: boolean) =&gt; number</span></span><br></pre></td></tr></table></figure><p>这个例子可能会在我们日常开发中用到，而且可以让我们回顾如何操作函数类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> AppendArgument&lt;Fn <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>, A&gt; = Fn <span class="keyword">extends</span> (</span><br><span class="line">  ...args: infer Args</span><br><span class="line">) =&gt; infer Res</span><br><span class="line">  ? <span class="function">(<span class="params">...arg: [...Args, A]</span>) =&gt;</span> Res</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h3 id="Append-to-object"><a href="#Append-to-object" class="headerlink" title="Append to object"></a>Append to object</h3><p><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00527-medium-append-to-object/README.md">原文地址</a></p><p>使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Test = &#123; <span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">type</span> Result = AppendToObject&lt;Test, <span class="string">&#x27;value&#x27;</span>, <span class="number">4</span>&gt; <span class="comment">// expected to be &#123; id: &#x27;1&#x27;, value:</span></span><br></pre></td></tr></table></figure><p>注意和 <code>Merge</code> 有所区别，这里是针对 <code>Object</code> 来操作</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> AppendToObject&lt;T, U, V&gt; = T <span class="keyword">extends</span> Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;</span><br><span class="line">  ? U <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">    ? &#123; [K <span class="keyword">in</span> keyof T | U]: K <span class="keyword">extends</span> U ? V : T[K] &#125;</span><br><span class="line">    : T</span><br><span class="line">  : T;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Typescript 特性相对完备，基于此可以完成非常复杂的需求，甚至使用 <a href="https://github.com/ronami/HypeScript">Typescript 来编写一个 Typescript Checker</a>，不过笔者认为，对于时间精力有限的一般工作中的开发者来说，知道“可以这样做”，并且在适当的时候可以通过简单的资料查阅完成需求，这一点可能更重要。</p><p>经过权衡，本文中只列举了部分 <a href="https://github.com/type-challenges/type-challenges">type–challenges</a> 中的内容，如果你还想了解更多，不妨看看原 github 仓库。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近期用了一定时间通读了 &lt;a href=&quot;https://github.com/type-challenges/type-challenges&quot;&gt;type-challenges&lt;/a&gt;，感慨 Typescript 也可以写的如此复杂之余，也出于以下几个原因，对题目做了整理，</summary>
      
    
    
    
    
    <category term="Typescript" scheme="https://z4ynadmin.github.io/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>使用 Rust 开发 python 模块</title>
    <link href="https://z4ynadmin.github.io/2022/06/04/python%E8%B0%83%E7%94%A8Rust/"/>
    <id>https://z4ynadmin.github.io/2022/06/04/python%E8%B0%83%E7%94%A8Rust/</id>
    <published>2022-06-04T09:34:05.000Z</published>
    <updated>2022-11-04T07:11:09.553Z</updated>
    
    <content type="html"><![CDATA[<p>关于 Rust 的基本介绍，我在之前的<a href="http://niexiaotao.cn/2021/09/02/%E4%BA%86%E8%A7%A3%20StackOverFlow%20%E4%B8%8A%E9%9D%A2%E6%9C%80%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E8%AF%AD%E8%A8%80%20Rust/">文章</a>有做过一些总结。</p><p>本篇文章我们关注如何在 python 中调用 Rust 开发的模块。</p><h2 id="Rust-FFI-的一般思路"><a href="#Rust-FFI-的一般思路" class="headerlink" title="Rust FFI 的一般思路"></a>Rust FFI 的一般思路</h2><p>Rust 可以编译出兼容 C ABI 的动态库或者静态库，Rust 调用其他语言，以及 Rust 被其他语言调用，基本都是通过 C ABI 来进行 FFI 调用。</p><p>所以我们可以看出，实际上 C++ 调用 Rust <em>并不是特别方便</em>，需要使用 Rust 提供的 C 接口，也因此没有办法使用 C++ 提供的类型，而 Rust 在导出接口的时候，也没有办法使用 Rust 的类型系统，需要转换成 C 类型。</p><p>大多数时候我们都会在这种场景下写一层 wrapper 和 converter，用来自动生成 FFI 层的一些胶水代码。</p><p>对于 Python 这类高级语言调用 Rust，基本也是类似的思路，我们可以简单总结为下图：</p><p><img src="/img/calling_rust_from_python_std_ffi_and_ctypes.png"></p><p>值得庆幸的是，对于 Python 调用 Rust，社区已经有非常多现成的成熟工具可以使用，基于这些工具，我们可以比较方便地专注于 Rust 实现逻辑本身，无需关注太多 FFI 和转换细节。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>一个比较方便的方法是使用 <a href="https://github.com/PyO3/pyo3">PyO3</a>，PyO3 不仅仅提供了 rust binding，也提供了创建 python 包的开箱即用的脚手架工具 <a href="https://github.com/PyO3/maturin">maturin</a>，使用 maturin 我们可以很方便地创建一个基于 rust 开发的 python 扩展模块。</p><p>我们这里整理一下官方文档中提供的最简单的方式，读者可以直接依次执行下面的 shell 脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir string_sum</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> string_sum</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建 venv 的这一步不能省略，否则后续运行的时候会报错</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python -m venv .env</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> .env/bin/activate</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pip install maturin</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接使用 maturin 初始化项目即可，选择 pyo3，或者直接执行 maturin init --bindings pyo3</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> maturin init</span></span><br><span class="line">✔ 🤷 What kind of bindings to use? · pyo3</span><br><span class="line">  ✨ Done! New project created string_sum</span><br></pre></td></tr></table></figure><p>这个时候，我们可以得到一个简单的 Rust 项目，并且包含了一个示例调用，我们无需修改任何代码，可以直接执行下面的命令测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> maturin develop 会自动打包出一个 wheel 包，并且安装到当前的 venv 中</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> maturin develop</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import string_sum</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; string_sum.sum_as_string(5, 20)</span></span><br><span class="line">&#x27;25&#x27;</span><br></pre></td></tr></table></figure><h2 id="进阶工具"><a href="#进阶工具" class="headerlink" title="进阶工具"></a>进阶工具</h2><p>接下来，我们介绍几个方便我们使用 Rust 开发 python 包的进阶工具或引导。</p><h3 id="setuptools-rust"><a href="#setuptools-rust" class="headerlink" title="setuptools-rust"></a>setuptools-rust</h3><p><a href="https://github.com/PyO3/setuptools-rust">setuptools-rust</a> 是一个 setuptools 的插件，让我们可以比较方便地编写使用 pyo3 开发的 rust python 包。</p><p>我们可以 clone 它的源代码，直接使用它提供的示例，参考如下命令测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> examples/rust_with_cffi</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python ./setup.py develop</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python</span></span><br><span class="line">Python 3.9.7 (default, Sep  3 2021, 12:37:55)</span><br><span class="line">[Clang 12.0.5 (clang-1205.0.22.9)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; from rust_with_cffi import rust</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; rust.rust_func()</span></span><br><span class="line">14</span><br></pre></td></tr></table></figure><h3 id="dict-derive"><a href="#dict-derive" class="headerlink" title="dict-derive"></a>dict-derive</h3><p>这个 rust 库提供了 FromPyObject 和 IntoPyObject 两个宏，使用这两个宏，我们可以很方便地进行 python dict 结构和 Rust 结构体的转换。</p><p>例如我们声明这样一个结构体：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(FromPyObject, IntoPyObject)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> name: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> email: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> age: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们就直接可以在导出函数中这样使用了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Requires FromPyObject to receive a struct as an argument</span></span><br><span class="line"><span class="meta">#[pyfunction]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_contact_info</span></span>(user: User) -&gt; PyResult&lt;<span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125; - &#123;&#125;&quot;</span>, user.name, user.email))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Requires IntoPyObject to return a struct</span></span><br><span class="line"><span class="meta">#[pyfunction]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_default_user</span></span>() -&gt; PyResult&lt;User&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(User &#123;</span><br><span class="line">        name: <span class="string">&quot;Default&quot;</span>.to_owned(),</span><br><span class="line">        email: <span class="string">&quot;default@user.com&quot;</span>.to_owned(),</span><br><span class="line">        age: <span class="number">27</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过宏展开可以发现，这两个宏所做的事情就是分别将 <code>pyo3::types::PyDict</code> 转换成 Rust 结构体和将 Rust 结构体转换成 <code>pyo3::types::PyDict</code>。</p><p>整体宏展开的代码不多，还是比较方便阅读的。</p><h3 id="rust-numpy"><a href="#rust-numpy" class="headerlink" title="rust-numpy"></a>rust-numpy</h3><p><a href="https://github.com/PyO3/rust-numpy">rust-numpy</a> 是一个 rust 版本的 numpy C ABI 封装，使用这个库我们可以在 Rust 中调用 numpy</p><p>接下来我们运行该库的示例代码。</p><p>我们需要先安装 nox，nox 是一个 python 自动化任务工具。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python3 -m pip install nox</span></span><br></pre></td></tr></table></figure><p>之后我们进入到命令行直接执行即可：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> examples/simple</span><br><span class="line"><span class="variable">$</span> nox</span><br></pre></td></tr></table></figure><p>顺利的情况下，我们可以看到它会输出测试成功：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tests/test_ext.py .....                                                                                                                                       [<span class="number">100</span><span class="comment">%]</span></span><br><span class="line"></span><br><span class="line">========================================================================= <span class="number">5</span> passed in <span class="number">0.32</span>s =========================================================================</span><br><span class="line">nox &gt; Session tests was successful.</span><br></pre></td></tr></table></figure><h3 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h3><p>在 Rust 中并没有直接和 python 中的 pandas 包对标的诸如 pandas-rs 包。</p><p>不过 Rust 标准库本身也提供了非常多的数据处理函数如筛选、过滤等，我们可以自己手写代码完成大部分 pandas 的工作。</p><p>在<a href="https://able.bio/haixuanTao/data-manipulation-pandas-vs-rust--1d70e7fc">这篇文章</a>中，作者使用了大约 160,000行/ 130列，总大小为 150Mb 的数据， 分别使用 Rust 和 Pandas 处理并测试，我们可以看到提升还是比较显著的：</p><table><thead><tr><th></th><th>Time(s)</th><th>Mem Usage(Gb)</th></tr></thead><tbody><tr><td>Pandas</td><td>3.0s</td><td>2.5Gb</td></tr><tr><td>Rust</td><td>1.6s 🔥 -50%</td><td>1.7Gb 🔥 -32%</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>pyo3 的 README 里面还列举了一些其他的工具库，使用起来相对比较简单，这里就不做单独介绍了。</p><ul><li><a href="https://github.com/vorner/pyo3-log">pyo3-log</a>：在 Rust 中使用 python 的 logging 库。</li><li><a href="https://github.com/PyO3/pyo3-built">pyo3-built</a>：可以在编译 rust 的 python 模块的时候写入一些构建信息，如 rust 版本等。</li><li><a href="https://github.com/awestlake87/pyo3-asyncio">pyo3-asyncio</a>：python asyio 的 Rust binding，可以将 python 的 async 转换成 Rust 的 features。</li><li><a href="https://github.com/mityax/rustimport">rustimport</a>：可以在 python 中直接引入 rust 代码，但因为引入的时候需要编译，笔者不是很建议在生产环境中直接使用。</li></ul><hr><p>虽然上面介绍了这么多工具，但是笔者认为，在实际使用中，还是远远不够的，我们应该还会结合业务，寻找和造出更多轮子，这部分工作就有待我们进一步开拓了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于 Rust 的基本介绍，我在之前的&lt;a href=&quot;http://niexiaotao.cn/2021/09/02/%E4%BA%86%E8%A7%A3%20StackOverFlow%20%E4%B8%8A%E9%9D%A2%E6%9C%80%E5%8F%97%E6%</summary>
      
    
    
    
    
    <category term="Rust" scheme="https://z4ynadmin.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>基于 Container 架构的多框架前端应用</title>
    <link href="https://z4ynadmin.github.io/2022/05/25/%E5%9F%BA%E4%BA%8Econtainer%E6%9E%B6%E6%9E%84%E7%9A%84%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/"/>
    <id>https://z4ynadmin.github.io/2022/05/25/%E5%9F%BA%E4%BA%8Econtainer%E6%9E%B6%E6%9E%84%E7%9A%84%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/</id>
    <published>2022-05-25T14:17:41.000Z</published>
    <updated>2022-11-04T07:11:09.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><p>本文提供一种用于构建多框架前端项目的思路，目前还尚未完整编写代码验证其可行性。</p><p>这种思路有些类似于<em>微前端</em>，实际上对于微前端来讲的话，社区已经有了 <a href="https://single-spa.js.org/">single-spa</a> 和基于其构建的 <a href="https://qiankun.umijs.org/zh/guide/tutorial">qiankun</a> 等若干方案。</p><p>这些框架都很优秀，也经过了不少生产项目的验证，能够在很大程度上满足微前端的需求。</p><p>但我个人觉得，对于一个团队规模不是很大，但是又存在不同技术栈的团队来说，直接使用这类微前端框架，会有一些负担，这主要体现在：</p><ol><li>各个微前端应用虽然可以互相调用，但是调用方式有限，对于复杂的内容比如通用 UI 模块的共享比较困难。</li><li>通常情况下，基座应用不够强大，一定程度上会加剧开发的独立性，不利于代码复用和共享。</li><li>原则上，<strong>对于小团队而言，我强烈建议统一成技术栈为 React 或者 Vue，没有任何道理可以支撑同时维护两套技术栈，但是如果想尝试一些新技术栈，可以在初期采用下述方案</strong>。</li></ol><p>我提出一种 Container 架构的前端应用，它可能应用在以下几个场景中：</p><ol><li>比如你想使用新的框架开发部分模块，例如使用 SolidJS 开发部分 React 项目中的组件，甚至使用 Rust 开发部分模块，用来做项目的实验性尝试。</li><li>出于团队人员技术栈的原因，需要 React 和 Vue 混合开发。</li><li>新的项目使用了 React，而旧的项目使用了 Vue，并且需要在短时间内把旧的项目放到新的项目中去使用。</li></ol><p>Container 架构的主要目的在于：</p><ol><li>增强基座项目的重要程度，从而做到尽可能更多地服用基础建设。</li><li>不仅模块本身可以用不同的框架编写，基座本身也可以被替换成不同的环境，例如：纯页面环境、定制化的 jupyter 环境、electron 环境。</li><li>可以让我们比较方便地进行部分模块先行升级，部分模块使用更高性能的技术栈开发同时尽可能多的复用现有基架。</li></ol><p>也就是说，<em>如果我们想换个语言开发，就新加一个模块就行，如果我们想换个地方运行，就新加一种基座就行</em>。</p><p>从而实现了双向自由度。</p><p>同时，它牺牲了一些内容：</p><ol><li>模块由于对基座项目的依赖性比较大，通常难以独立部署。</li></ol><h2 id="核心架构图"><a href="#核心架构图" class="headerlink" title="核心架构图"></a>核心架构图</h2><p>核心围绕一套 Container Abstract API 来展开。</p><p><img src="/img/absapp.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">node WebApp</span><br><span class="line">node JupyterApp</span><br><span class="line">node ElectronApp</span><br><span class="line">node BaseApp</span><br><span class="line">artifact ContainerAbstractAPI</span><br><span class="line">node ReactModule1</span><br><span class="line">node ReactModule2</span><br><span class="line">node VueModule</span><br><span class="line">node SolidModule</span><br><span class="line">WebApp .. BaseApp : 继承</span><br><span class="line">JupyterApp .. BaseApp : 继承</span><br><span class="line">ElectronApp .. BaseApp : 继承</span><br><span class="line">BaseApp .. ContainerAbstractAPI: 提供</span><br><span class="line">ContainerAbstractAPI .. ReactModule1 : 依赖</span><br><span class="line">ContainerAbstractAPI .. ReactModule2 : 依赖</span><br><span class="line">ContainerAbstractAPI .. VueModule : 依赖</span><br><span class="line">ContainerAbstractAPI .. SolidModule : 依赖</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p>真正应用部署的时候，选取一个 App，以及几个对应的 Module，就可以组合出我们的一套需要的项目。</p><p>针对这一套架构，对于通用的部分，我们尽可能地实现在 BaseApp 里面。</p><p>BaseApp 应该是比较少量的，一个团队中甚至只有一个，它可能会用到一些组件库或者框架，这些都可以的。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>对于这套架构的一个示例代码实现，我会在后续文章中给出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念介绍&quot;&gt;&lt;a href=&quot;#概念介绍&quot; class=&quot;headerlink&quot; title=&quot;概念介绍&quot;&gt;&lt;/a&gt;概念介绍&lt;/h2&gt;&lt;p&gt;本文提供一种用于构建多框架前端项目的思路，目前还尚未完整编写代码验证其可行性。&lt;/p&gt;
&lt;p&gt;这种思路有些类似于&lt;em&gt;微前</summary>
      
    
    
    
    
    <category term="前端综合" scheme="https://z4ynadmin.github.io/tags/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>我们应该如何进行 Code Review ?</title>
    <link href="https://z4ynadmin.github.io/2022/04/25/%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4MR%E7%9A%84%E9%87%8D%E7%82%B9%E5%85%B3%E6%B3%A8%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86/"/>
    <id>https://z4ynadmin.github.io/2022/04/25/%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4MR%E7%9A%84%E9%87%8D%E7%82%B9%E5%85%B3%E6%B3%A8%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86/</id>
    <published>2022-04-25T12:35:00.000Z</published>
    <updated>2022-11-04T07:11:09.555Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在日常工作中会发现，时常会存在一些比较显而易见或者已知的一类问题，在开发者提交代码以及相关同学 Review 中均未被发现。</p><p>这里的一个原因在于，代码开发者在某些时候会提交较多代码，而此时 Reviewer 面对较多代码的 Review 的时候，很可能会漏掉一些 Review 的要点，甚至可能会感到无所适从。本文希望，针对一些非场景化的内容，整理出一些较为普适的一些原则，从而帮助 Reviewer（以及开发者本身）解决一些通用的问题。</p><h2 id="格式与规范"><a href="#格式与规范" class="headerlink" title="格式与规范"></a>格式与规范</h2><p>原则上，这部分内容不应该在 Review 的时候去处理，我们应该配置代码格式规范工具，在提交代码前或者 MR 的 CI 流水线中做这个事情。</p><p>这里对于不同类型的语言，大多社区都有现成的方案，不过多赘述，如果你在代码 Review 的时候还在纠结于格式和规范，那么现在就去配置好对应的工具。</p><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>这里的稳定性，指的是我们程序在运行阶段的稳定性，以及当出现错误，我们能够第一时间发现。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>关于这里，最常见的一种代码是：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (some<span class="number">_</span>error<span class="number">_</span><span class="keyword">case</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种类似的代码，虽然看似兜底兜住了错误，但是并没有日志输出，也没有更多的提示，长久之后很可能会形成暗坑。</p><p>对于这种代码我们应该思考：</p><ul><li>是否应该打一个错误日志，提供一些上下文信息。</li><li>是否应该增加异常上报，让我们优化这种问题。</li><li>是否需要将这个错误信息返回给调用方或者调用端。</li><li>用户层面是否需要感知此信息，如果需要，方法是什么。</li></ul><p>另外还有一种比较常见的是异常，包括代码运行抛出的异常和我们自己捕获/抛出的异常：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">if</span></span> (<span class="variable">some_error_case</span>) &#123;</span><br><span class="line">    <span class="variable">throw</span> <span class="variable">new</span> <span class="function"><span class="title">Error</span>(<span class="string">&#x27;some error&#x27;</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="variable"><span class="keyword">try</span></span> &#123;</span></span><br><span class="line"><span class="function">    <span class="title">error_call</span>()</span></span><br><span class="line">&#125; <span class="function"><span class="title">catch</span>(<span class="variable">e</span>) &#123;</span></span><br><span class="line"><span class="function">    <span class="title">log</span>(<span class="variable">e</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这类异常的处理逻辑，和上面的异常条件逻辑比较类似，我们应该同样思考上述四点。</p><h2 id="保护用户隐私"><a href="#保护用户隐私" class="headerlink" title="保护用户隐私"></a>保护用户隐私</h2><p>隐私通常涉及到法律合规，因此可能是最重要的一环。</p><h3 id="用户的隐私不可泄漏"><a href="#用户的隐私不可泄漏" class="headerlink" title="用户的隐私不可泄漏"></a>用户的隐私不可泄漏</h3><ul><li>比如在开发功能打日志的时候，我们应该不能泄漏用户的隐私，例如用户的自定义信息、聊天信息等。</li></ul><p>这一部分建议在团队内部形成一个统一的规范文档，在开发和 Review 的过程中，大家都可以以此为依据。</p><h3 id="自己的隐私不可泄漏"><a href="#自己的隐私不可泄漏" class="headerlink" title="自己的隐私不可泄漏"></a>自己的隐私不可泄漏</h3><p>很多时候，我们虽然注意到了用户的隐私，但是<strong>自己的隐私</strong>却没有注意，这里主要是我们的一些 appKey、密钥等内容。无论是在以下哪些场景，我们都需要格外注意：</p><ul><li>对产物进行二次分发，例如分发到内部或外部 npm、github 以及其他团队，特别是外网可访问的情况更需要注意。</li><li>直接给到用户使用，例如在 Web 环境使用，或者打包到桌面端应用，尽量避免用户直接接触到这些内容。</li></ul><h2 id="可读性-维护性"><a href="#可读性-维护性" class="headerlink" title="可读性/维护性"></a>可读性/维护性</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>代码中函数和变量的命名，是可读性中比较重要的一个关注点。</p><p>关于如何命名，实际上很多架构书籍也都会额外列出一章来讲，在这里我不想过多进行赘述。不过一般来说，我们的命名应当清晰易懂，避免出现没有实际意义的含糊的变量名。</p><h3 id="代码提交的注释"><a href="#代码提交的注释" class="headerlink" title="代码提交的注释"></a>代码提交的注释</h3><ul><li><p>对于 bug fix：很多时候我们是在处理一个边界问题，或者某种兜底，这个时候 fix 的代码可能比较难以理解，在这种情况下我们最好是写明注释，如果有相关的文档和 bug 单，我们也可以一并贴到注释中。另外，如果我们的 bug fix 是一个临时方案，请在代码中写明 <strong>TODO</strong>，来提醒自己和别人这个地方后续还会继续更改。</p></li><li><p>对于新功能添加：一般我们需要在关键入口处写明功能的说明文档链接、完善相关关键路径的注释，同时删除功能开发中的冗余代码：例如我们在开发过程中测试用到但是最终却没有用到的大段注释掉的代码，以及大段的注释和 TODO，我们都需要在最终提交的时候<strong>删除掉</strong>，如果需要找回建议使用 git 的能力，可以适当进行注释备注。</p></li><li><p>另外，对于注释来说，<strong>禁止出现</strong>模糊的词汇，例如 <strong><code>感觉</code>，<code>好像</code>，<code>大概</code></strong> 等这种模糊的词汇，而是要培养自己严谨的意识，已经提交的代码必须有严格的佐证。</p></li></ul><h3 id="日志可读性"><a href="#日志可读性" class="headerlink" title="日志可读性"></a>日志可读性</h3><p>大多数项目的问题定位非常依赖日志。</p><p>对于日志，我们应该有如下几个约束：</p><ul><li>避免太多太长的内容，无论日志是以何种方式存储，规模上去之后的消耗都非常可观。</li><li>适当使用简写，但是避免完全不知所云，应该符合普遍约定。</li></ul><h3 id="代码的通用性"><a href="#代码的通用性" class="headerlink" title="代码的通用性"></a>代码的通用性</h3><p>当我们提交一个功能，或者修复一个问题的时候，很多时候我们只是从这个问题的角度护发，但是并没有从全局的角度出发，例如：</p><ul><li>当我们新增一个上报的时候，有没有考虑把整个上报聚合到一起，或者架构上支持更方便的上报能力？</li><li>当我们新增一个通用能力的时候，有没有考虑到其他模块或项目也可能有类似需求，我们是否可以将其单独抽离成一个独立的包进行分发？</li><li>当我们遇到一个问题有多种修复方案的时候，有没有综合考虑，哪一种方案对后续维护的同学更加友好（比如，最好是高内聚、低耦合的设计）？</li></ul><p>这里的大体原则，就是我们需要从整体性的角度出发，不断地迭代让整个架构更加夯实，而不是出个问题贴一个创可贴，新增功能又贴一个创可贴。</p><h3 id="配置化"><a href="#配置化" class="headerlink" title="配置化"></a>配置化</h3><p>这里的配置化，比较典型的比如是：多语言文案、项目 Settings 配置等。</p><ul><li>一般来说，配置化的内容最好是走云端下发。</li><li>如果不具备云端下发的环境，或者我们的配置<strong>比较敏感不适合直接下发</strong>，可以考虑在代码中创建配置文件的方式。</li></ul><p>如果我们在 Review 中发现有可以配置化的内容但是却直接写死在代码里面了，应当需要提出质疑。</p><h3 id="代码精简"><a href="#代码精简" class="headerlink" title="代码精简"></a>代码精简</h3><p>代码精简对后期的可维护性是非常重要的，代码精简的一个比价有效的办法就是充分理解业务，写出精简不多余的代码，不过这一点在 MR 中可能会比较难进行 Review，因为一般来说提交代码的同学本身已经是对这部分业务是理解的最透彻的。</p><p>但是有一点代码的 Reviewer 会比较容易判断，如果我们提交的代码里面有<strong>两处以上超过三行的极其相似的代码</strong>，我们就应当重新审视是否可以进行一定程度的抽离，建议不要由于一时的效率允许不符合规范的代码合入，这些在后期都可能演化成代码屎山。</p><p>例如，笔者对于 Rust 代码精简的一些建议：</p><ul><li>避免任何一次多余的 Clone。</li><li>文件头部引用中去除没有必要的引用。</li><li>避免多余的日志，同时避免在日志里面加太长的前缀内容（有的时候一行日志里面有多半都是元信息，而且这些元信息还是有所重复的）。</li><li>避免多余的 pub，应该有一个理念就是默认的内容不要 pub 出去，就像 c++ 的成员方法默认是 private 一样。</li><li>重复代码使用宏来替代。</li></ul><h2 id="重视性能"><a href="#重视性能" class="headerlink" title="重视性能"></a>重视性能</h2><h3 id="防止泄漏"><a href="#防止泄漏" class="headerlink" title="防止泄漏"></a>防止泄漏</h3><p>在考察性能之前，我们需要保证自己的代码没有泄漏，因为泄漏造成的恶劣性通常比性能差更严重，而且通常需要更长的时间来排查。</p><p>这里主要的检查点可以是：</p><ul><li>addListener 之后是否及时释放了。</li><li>setInterval/setTimeout 等定时器调用是否存在多次调用的可能性，以及是否可能无法释放。</li><li>分配在堆上的内存是否释放了。</li><li>是否有 detach dom 泄漏。</li></ul><h3 id="防止死锁"><a href="#防止死锁" class="headerlink" title="防止死锁"></a>防止死锁</h3><p>这一点如果是前端开发，一般没有机会遇到，但如果你用 rust、c++ 等语言，都很有可能出现死锁的风险（严格来说，死锁并不能直接归类到性能）。</p><p>对于死锁的防止，我建议团队内的基础设施部分先配置好死锁检测和上报机制（例如 parking_lot 提供了死锁检查的能力）。</p><p>一些死锁相关的 Review 建议：</p><ul><li>用到锁的地方，尽可能通过工具函数进行封装，类似 getter 和 setter，增加原子性，减少调用代码直接解锁的场景。</li><li>锁的粒度不应该太大，<strong>我们应该是对数据进行加锁，而不是对过程进行加锁</strong>，锁粒度过大很容易出现死锁的风险。</li><li>在函数脱离控制权之前，例如准备开始调用到其他外部函数了，这个时候最好把持有的锁都释放掉，防止外部函数再次用到造成锁重入。</li></ul><h3 id="性能报告"><a href="#性能报告" class="headerlink" title="性能报告"></a>性能报告</h3><p>关于这一部分，也建议团队基建先行，有一个比较标准的性能测试方法，这样大家在做性能测试的时候，不会那么有压力。比较反对的一种方式就是团队内部不同成员都有自己的一套性能测试方法，这样有些新同学缺乏必要的上下文，自然不了解如何去做性能测试。</p><p>一般来说，我们涉及到比较大的功能都要进行一些性能报告，相关的指标可以是：</p><ul><li>整体包体积的增加幅度。</li><li>初始化响应速度的变化。</li><li>运行该功能一段时间的 CPU 消耗。</li><li>运行该功能一段时间的 内存 消耗。</li><li>运行该功能较长时间的 CPU/内存 消耗。</li></ul><p>不过，具体这一部分还是建议团队内部根据项目的实际情况有一个统一的标准，并且将性能测试方法标准化，而不要成为一个负担。</p><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>在兼容性这方面，无论是 web 开发还是桌面客户端开发，都需要重点关注，这里其实细分为两个维度：</p><ul><li>版本支持，例如我们可能会实现约定好支持到 Chrome 的哪个版本（针对 web）或者 macOS 的哪个版本（针对 macOS 桌面端），并且如果提交涉及到兼容性改动需要重点测试所支持的最低版本。</li><li>异常情况支持，这一点可能大多数时候都会被大家忽略，这里举一个例子就是 webgl 的支持，实际上，虽然大多数时候浏览器已经支持到了 webgl，但是仍然有不少场景，webgl 会初始化失败，这个原因可能和用户的硬件比如系统显卡有关，如果我们的项目只有 webgl 实现，我们需要考虑是否放弃 webgl 初始化失败的场景（从商业化的角度，一般来说都是希望不要放弃），或者说为此增加软渲染降级。</li></ul><p>所以，在 Code Review 环节，针对可能出现兼容性风险的地方，我们需要确认是否已经进行了兼容性测试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;笔者在日常工作中会发现，时常会存在一些比较显而易见或者已知的一类问题，在开发者提交代码以及相关同学 Review 中均未被发现。&lt;/p&gt;
&lt;p&gt;这里的一个原因在于，代码开发者在某些时候会提交较多代码，而此时 Reviewer 面对较多代码的 Review 的时候，很可能会漏</summary>
      
    
    
    
    
    <category term="编程综合" scheme="https://z4ynadmin.github.io/tags/%E7%BC%96%E7%A8%8B%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>《代码整洁之道-Clean Code》读书笔记</title>
    <link href="https://z4ynadmin.github.io/2022/02/27/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"/>
    <id>https://z4ynadmin.github.io/2022/02/27/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/</id>
    <published>2022-02-27T05:21:39.000Z</published>
    <updated>2022-11-04T07:11:09.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整洁代码"><a href="#整洁代码" class="headerlink" title="整洁代码"></a>整洁代码</h2><p>《修改代码的艺术》一书作者对整洁代码的描述：我可以列出我留意到的整洁代码的所有特点，但其中有一条是根本性的，整洁的代码总是看起来像某种特别在意他的人写的，几乎没有改进的余地，代码的作者什么都想到了，如果你企图改进它，总会回到原点，赞叹某人留给的代码——全心投入某人留给你的代码。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>这本书关于函数的介绍和其他架构书差不多，主要就是两个点：1. 短小，2. 抽象层次一致性。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>毫无疑问，注释是代码中的坏味道。</p><p>对于一部分注释，我们可以使用类似 4.4.8 这种变量的方式，通过新增两个变量，来解释我们的内容。<br>那种生成的注释和我们注释掉的代码，我的建议是：不要留。</p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>相关函数：按照本书的说明，若某个函数调用了另外一个，就应该把它们放到一起，而且调用者应该尽可能放在被调用者上面。我自己之前的习惯是调用者在被调用者的下面，目前又思考了一下，像作者这样组织，可能可读性反而更高。</p><blockquote><p>因为这样设计可以像报纸一样，最重要的概念先出现，并且希望以包括最小的细节表述他们，期望底层的细节后出现。</p></blockquote><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p><strong>使用异常而非返回码</strong>： 在 《代码精进之路》的读书笔记中，也提及了类似的思路，这个书里面又提到了使用异常而非返回码这一点，并且给出了一个新的理由，返回码意味着我们需要立即处理，这个步骤可能很容易被遗忘，而且会让我们的代码变得比较乱。</p><p>关于返回 null 值：有的时候，我们在数据处理中出现问题，可能会返回一个 null 或者 undefined。但是我建议相对于此，我们更应该直接抛出异常，返回 null 值意味着依赖调用者来做空检查，而且你不知道这个 null 究竟什么时候才会引发错误，这样会有较高的不稳定性。</p><h2 id="类的组织"><a href="#类的组织" class="headerlink" title="类的组织"></a>类的组织</h2><p>对于类的组织中，属性顺序的一个建议：依次是公共静态常量、私有静态变量、公共函数、私有函数。</p><p><strong>类的权责</strong>：对于一个类来说，我们不希望它被定义的太长，当然这个不能单纯地使用代码行数来判断，我们应该使用类的权责来判断，当一个类的名称越含糊，该类越有可能拥有更多权责，比如它的名称包含了诸如 Processor、Manager 或 Super，那么这种现象往往说明有不恰当的权责聚集的情况出现。</p><p><strong>如何把类拆的短小</strong>：我给出一个切实可行的办法，可以先从类的复杂函数入手，我们在把函数拆分的过程中，发现某些部分拆分成函数之后会传递大量的参数给它，否则很难拆分，那么传递给它这个函数的参数就可以被整合进新的小类的实体变量，这样我们就无需传递参数，同时也完成了拆分。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;整洁代码&quot;&gt;&lt;a href=&quot;#整洁代码&quot; class=&quot;headerlink&quot; title=&quot;整洁代码&quot;&gt;&lt;/a&gt;整洁代码&lt;/h2&gt;&lt;p&gt;《修改代码的艺术》一书作者对整洁代码的描述：我可以列出我留意到的整洁代码的所有特点，但其中有一条是根本性的，整洁的代码总是看</summary>
      
    
    
    
    
    <category term="读书笔记" scheme="https://z4ynadmin.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用 fst-json 自动生成更快的 json 序列化方法</title>
    <link href="https://z4ynadmin.github.io/2022/02/11/fst-json/"/>
    <id>https://z4ynadmin.github.io/2022/02/11/fst-json/</id>
    <published>2022-02-11T10:45:54.000Z</published>
    <updated>2022-11-04T07:11:09.553Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>fst-json 的全称是 “fast-safe-typescript json”，它的本质就是直接使用你定义好的 Typescript 文件，来生成更加高效的序列化方法。<br>其目的是利用现有的资源（开发过程编写的 Typescript 文件），在编译和开发阶段尽可能提高运行时性能，同时这个过程并没有额外的开发负担。</p></blockquote><p>github: <a href="https://github.com/aircloud/fst-json/blob/master/README.zh-cn.md">https://github.com/aircloud/fst-json/blob/master/README.zh-cn.md</a></p><p>知乎：<a href="https://zhuanlan.zhihu.com/p/466572196">https://zhuanlan.zhihu.com/p/466572196</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于 JSON schema 这个概念是由 fastify 引入，我们先对此进行介绍。</p><p><a href="https://github.com/fastify/fastify">fastify</a> 是一个高性能 Node.JS 服务端框架，其特点就是高性能，而之所以高性能主要的原因就是它引入了 JSON schema，通过对参数增加约束，来获得更快的序列化速度。</p><p>同时，fastify 也开源了一个独立的 json 序列化库 <a href="https://github.com/fastify/fast-json-stringify">fast-json-stringify</a>，可以在<strong>非 fastify 的项目中使用</strong>。</p><p>在 fastify 中，JSON schema 的大致写法如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const schema = &#123;</span><br><span class="line">  <span class="keyword">schema</span>: &#123;</span><br><span class="line">    response: &#123;</span><br><span class="line">      <span class="number">200</span>: &#123;</span><br><span class="line">        <span class="keyword">type</span>: <span class="string">&#x27;object&#x27;</span>,</span><br><span class="line">        properties: &#123;</span><br><span class="line">          hello: &#123;</span><br><span class="line">            <span class="keyword">type</span>: <span class="string">&#x27;string&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fastify</span><br><span class="line">  .<span class="keyword">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">schema</span>, <span class="keyword">function</span> (req, reply) &#123;</span><br><span class="line">    reply</span><br><span class="line">      .send(&#123; hello: <span class="string">&#x27;world&#x27;</span> &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>我们可以看出，这一套写法不仅会带来额外的学习成本，而且由于目前大多数项目开发都是采用 Typescript，这套定义也会和我们的 Typescript 定义有所重复。</p><p>事实上，虽然上面的示例代码比较短小，但是在实际的项目中，接口比较多的情况下，这些代码的开发量和额外的学习/维护成本还是不容小视的。</p><p>那么有没有可能直接使用 Typescript，而不用重新定义 JSON schema 呢？</p><p>答案是有的。</p><p><a href="https://github.com/aircloud/fst-json/blob/master/README.zh-cn.md">fst-json</a> 就是这样一个工具，它可以通过复用我们在 Typescript 中定义的 schema，通过工具自动生成 fastify 需要的 schema，这样我们就无需额外维护 schema 定义了。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>接下来，我们简单介绍 fst-json 的使用方式，首先安装（全局或者安装到项目中）：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> i fst-json -g</span><br></pre></td></tr></table></figure><p>假设我们项目采用了 Typescript，事先已经有了 schema 文件：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">interface</span> <span class="symbol">HellWorld</span> &#123;</span><br><span class="line">  attr1: <span class="built_in">string</span>;</span><br><span class="line">  attr2: <span class="built_in">string</span>;</span><br><span class="line">  attr3?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在项目目录下新建 .fstconfig.js，用于声明配置，配置如下：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = &#123;</span><br><span class="line">  sourceFiles: [</span><br><span class="line">    <span class="string">&#x27;./src/schema/*.ts&#x27;</span></span><br><span class="line">  ],</span><br><span class="line">  distFile: <span class="string">&quot;./src/schema-dist.ts&quot;</span>,</span><br><span class="line">  format: <span class="string">&#x27;fastify&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们运行：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fst-json gen</span></span><br></pre></td></tr></table></figure><p>然后此时会生成一个 <code>src/schema-dist.ts</code>，这里会有自动生成的 JSON schema 定义，接下来我们在项目中可以同时使用 JSON schema 定义和我们之前定义好的 Typescript 类型：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="keyword">schemas</span> <span class="keyword">from</span> <span class="string">&#x27;./schema-dist&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; HellWorld  &#125; <span class="keyword">from</span> &quot;./schema&quot;;</span><br><span class="line"></span><br><span class="line">const schema = &#123;</span><br><span class="line">  <span class="keyword">schema</span>: &#123;</span><br><span class="line">    response: &#123;</span><br><span class="line">      <span class="number">200</span>: <span class="keyword">schemas</span>.HellWorldSchema</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">server</span></span><br><span class="line">  .<span class="keyword">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">schema</span>, <span class="keyword">function</span> (req, reply) &#123;</span><br><span class="line">    let res: HellWorld = &#123;</span><br><span class="line">      attr1: <span class="string">&#x27;hello&#x27;</span>, </span><br><span class="line">      attr2: <span class="string">&#x27;world&#x27;</span>, </span><br><span class="line">      attr3: <span class="string">&#x27;optional&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reply</span><br><span class="line">      .send(res);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>当然，fst-json 不仅仅可以在 fastify 中使用，也可以在任何其他需要 JSON 加速的地方使用，用法也都很简单，可以参考这个 <a href="https://github.com/aircloud/fst-json/tree/master/examples/helloworld">HelloWorld</a></p><h2 id="原理和优势"><a href="#原理和优势" class="headerlink" title="原理和优势"></a>原理和优势</h2><p>fst-json，实际上是通过对 Typescript 进行语法树解析，针对 export 导出的各种类型生成对应的 fast-json-stringify 的 JSON schema，所以运行速度和手写是没有区别的。因此，它不仅仅能完全使用 fast-json-stringify 的效率优势，除了减少重复开发量以外还有如下优点：</p><ul><li><strong>根据 schema 进行字段校验：</strong> 首先会进行 Tyepscript 语法校验，另外当缺失必须的属性（例如，当定义 interface 时没有被 <code>?</code> 修饰符修饰的属性缺失）的时候也会直接报错。</li><li><strong>过滤不需要的 schema 字段：</strong> 例如当把 Node.JS 当作 BFF 层的时候，可以严格按照 Typescript 的定义来返回字段，避免返回不需要的字段，从而避免上游服务的敏感字段被直接透传出去，也意味着从接口层面开始，真正做到 Fully Typed。</li><li><strong>更快的序列化速度：</strong> 根据 <a href="https://github.com/fastify/fast-json-stringify/issues">fast-json-stringify</a> 的测试，能达到接近 2 倍的 JSON 序列化速度。</li></ul><p>目前，fst-json 对常用的各类 interface、class、type 等类型定义都进行了支持，并且增加了各类 examples 和 90% 的覆盖率测试。</p><p>当然，由于 Typescript 的写法比较灵活。出于 JSON schema 本身的局限性，我们无法覆盖所有场景，所以也可以参考这里的<a href="https://github.com/aircloud/fst-json/blob/master/README.zh-cn.md#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a>，有针对性的对比较容易出问题的写法进行规避。</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>fst-json 只是语法解析和生成工具，具体的运行时，实际上就是在使用 fast-json-stringify，也因此项目中需要安装 fast-json-stringify 依赖。</p><p>另外，针对 fast-json-stringify 的测试，在比较小的 payload 的情况下，它的速度是有优势的，当 payload 过大的时候，它的优势不再明显，甚至还不如 JSON.stringify。官方的描述是：</p><blockquote><p>fast-json-stringify is significantly faster than JSON.stringify() for small payloads.<br>Its performance advantage shrinks as your payload grows.</p></blockquote><p>不过事实上，这个时候你仍然可以使用 fst-json 做一些事情，例如笔者使用 fst-json 来做 bff 层对下游服务接口的持续集成兼容测试，在 Typescript 已经提前定义好了的情况下，每次测试的时候只需要请求依赖服务并且把响应字段序列化，如果没有报错并且字段序列化之后也没有变成 null（在比较复杂的接口定义中，如果个别属性定义类型和返回类型不一致，fast-json-stringify 是会直接转换成 null），就说明接口是没有变化的。可以有效避免依赖服务接口变化，却又没有及时同步到位造成暗坑的情况。</p><p>另外，其实目前 fast-json-stringify 生成序列化代码还是在运行时做的，这里的问题可能在于代码不透明，以及运行时开销和风险，笔者是希望将它的生成代码变成编译时去做，不过这样的话实际上有一点重复造轮子的错觉，所以目前还没有做这个事情。</p><hr><p>最后 <a href="https://github.com/aircloud/fst-json/">fst-json</a> 作为一个开源不久的小项目，肯定还有些需要优化和完善的地方，欢迎 star 支持和提出建议。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;fst-json 的全称是 “fast-safe-typescript json”，它的本质就是直接使用你定义好的 Typescript 文件，来生成更加高效的序列化方法。&lt;br&gt;其目的是利用现有的资源（开发过程编写的 Typescript 文件）</summary>
      
    
    
    
    
    <category term="前端综合" scheme="https://z4ynadmin.github.io/tags/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>《代码精进之路》与《代码整洁之道》-读书笔记</title>
    <link href="https://z4ynadmin.github.io/2022/01/30/%E3%80%8A%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%E3%80%8B%E4%B8%8E%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://z4ynadmin.github.io/2022/01/30/%E3%80%8A%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%E3%80%8B%E4%B8%8E%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-30T08:14:15.000Z</published>
    <updated>2022-11-04T07:11:09.555Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过对部分重点内容罗列的方式对此两本书的读书笔记进行记录。</p><blockquote><p>《代码整洁之道-程序员的职业素养》</p></blockquote><h2 id="软件开发原则"><a href="#软件开发原则" class="headerlink" title="软件开发原则"></a>软件开发原则</h2><p>所有软件项目的根本指导原则是，软件要<strong>易于修改</strong>。如果违背这条原则搭建僵化的结构，就破坏了构建整个行业的经济模型。</p><h2 id="必备技能"><a href="#必备技能" class="headerlink" title="必备技能"></a>必备技能</h2><p>软件开发人员必须精通的事项：</p><ul><li>设计模式：必须能描述 GOF 书中的全部 24 种模式和，同时还要有 POSA 书中的多数模型的实践经验。</li><li>设计原则：必须了解 SOLID 原则，而且要深刻理解组件设计原则。</li><li>方法：必须理解 XP、Scrum、精益、看板、瀑布、结构化和分析以及结构化编程。</li><li>实践：必须掌握测试驱动开发，面向对象设计，结构化编程，持续集成和结对编程。</li><li>工作：必须了解如何使用 UML 图，DFD 图，结构图，Petri 网络图，状态迁移图表，流程图和决策表。</li></ul><h2 id="不要说“我试试”"><a href="#不要说“我试试”" class="headerlink" title="不要说“我试试”"></a>不要说“我试试”</h2><ul><li>这种类型的描述并不是承诺，实际上并没有实际意义。</li><li>而且这通常意味着你之前评估周期的时候<strong>并没有竭尽全力</strong>，否则为什么在压缩周期的讨论中还要再说“我试试”呢。</li></ul><h2 id="重新定义“完成”"><a href="#重新定义“完成”" class="headerlink" title="重新定义“完成”"></a>重新定义“完成”</h2><ul><li>有的时候，我们自欺欺人的认为任务已经完成的足够好了，然后转入下一项任务。我们会给自己找借口说，其他还没来得及完成的工作可以等到时间更充裕的时候来处理。甚至有的时候，我们会把代码提交定义为”任务完成“。这样显然是错误的。</li><li>真正的任务完成，是已经通过了测试，并且上线完成等。</li></ul><h2 id="寻求帮助"><a href="#寻求帮助" class="headerlink" title="寻求帮助"></a>寻求帮助</h2><ul><li>编程并非易事。越年轻的程序员可能越没有感觉，毕竟代码只不过是一堆 if 和 while 语句而已。但是随着经验增长，你会开始意识到把这些 if 和 while 语句组装在一起并非易事。不能期望将他们简单的组装到一起就能得到最好的代码。相反，必须小心谨慎地将系统分解为易于理解的单元，同时使得这些单元之间的联系越少越好。</li><li>因此，仅凭一己之力很难写出足够优秀的代码，即使你的技艺足够高超。<strong>也一定能从另外一名程序员的思考和想法中获益。</strong></li></ul><h2 id="重新认识争论"><a href="#重新认识争论" class="headerlink" title="重新认识争论"></a>重新认识争论</h2><ul><li>凡是不能在 5 分钟内解决的争论，都不能通过辩论来解决。争论之所以要花费这么长时间，是因为争论双方都拿不出足够有力的证据，这个时候争论依据的不是事实，而是信念。</li></ul><h2 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h2><ul><li>成员需要克服个体差异性，默契配合，彼此信任，形成真正有凝聚力的团队，是需要一些时间的。可能需要 6 个月，甚至一年，但是，凝聚力一旦形成，就会产生一种神奇的魔力。团队成员会一起做计划，一起解决问题，一起面对问题，<strong>一起解决一切</strong>。</li></ul><blockquote><p>《代码精进之路》</p></blockquote><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>一般来说我们都知道命名应该有可读性，但是像这里介绍这么详细的并不多。</p><p>例如我们针对命名可以通过固定分段限定词的方式进行统一：</p><ul><li><code>[动作][对象][范畴]</code>，来统一我们的命名，例如 <code>getRevenueTotal(获取总收入)</code>。</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li>注释如果是对执行过程的简单复述，那么这样的注释不应该存在。</li><li>我们可以通过函数和中间变量的封装，来减少可以避免的注释。</li></ul><h2 id="错误和错误码"><a href="#错误和错误码" class="headerlink" title="错误和错误码"></a>错误和错误码</h2><p>我们可以通过以下几种方式处理错误（中后台系统比较合适）：</p><ol><li>程序运行期间的错误，一般我们可以通过 Error 打印到日志中，而且这类错误，最好和报警系统进行对接，直接输出到报警系统中。</li><li>API/服务调用错误，这种错误一般通过错误码返回给调用端的同时，也需要在日志做好记录。</li></ol><blockquote><p>关于错误码：错误码我们可以使用数字或者显示化错误码，数字的坏处即我们需要额外维护错误码表，调用者可能并非我们团队，有可能造成沟通障碍。<br>因此，更建议使用<strong>显示化错误码</strong>，并且可以做一个约定：P 代表参数异常，B 代表业务异常，S 代表系统异常，例如：P_Customer_NameIsNull 客户姓名不能为空</p></blockquote><h2 id="代码中的破窗效应"><a href="#代码中的破窗效应" class="headerlink" title="代码中的破窗效应"></a>代码中的破窗效应</h2><p>破窗效应在代码中很常见，通常在我们完成一个功能的时候，都是基于现有代码的改动，如果你可以基于一个现有代码的不良设计完成功能（例如，在已经很混乱的事件订阅类增加一个 Enum、在已经很冗长的 Http 请求列表复制一个新的出来），那么大概率你会这样做而不是重构，<strong>特别是当这个不良设计不是你最初写的时候，就更加可以心安理得的改代码而没有任何负罪感，甚至在 Code Review 的时候都可以有充足的理由：它已经是这样了，这次先上，将来找个时间整体重构才行。</strong></p><h2 id="SLAP"><a href="#SLAP" class="headerlink" title="SLAP"></a>SLAP</h2><p>SLAP：Single Level of Abstraction Principle，抽象层次一致性</p><p>SLAP 要求函数体中的内容必须在同一个抽象层次上，如果高层次抽象和低层次细节杂糅在一起，就会显得凌乱，难以理解。</p><h2 id="如何述职"><a href="#如何述职" class="headerlink" title="如何述职"></a>如何述职</h2><ul><li>方法1: <strong>提出问题，定义问题，分析问题，解决问题，最后展望未来</strong>。这个也是麦肯锡常用的方法。</li><li>方法2: 我们说事情的时候，应该像电影镜头一样，先由远拉近，再由近拉远。从宏观背景，到怎么做的，到结果和思考。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文通过对部分重点内容罗列的方式对此两本书的读书笔记进行记录。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《代码整洁之道-程序员的职业素养》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;软件开发原则&quot;&gt;&lt;a href=&quot;#软件开发原则&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="读书笔记" scheme="https://z4ynadmin.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《重构》-读书笔记</title>
    <link href="https://z4ynadmin.github.io/2022/01/02/%E9%87%8D%E6%9E%84-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://z4ynadmin.github.io/2022/01/02/%E9%87%8D%E6%9E%84-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-02T06:11:39.000Z</published>
    <updated>2022-11-04T07:11:09.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始重构"><a href="#开始重构" class="headerlink" title="开始重构"></a>开始重构</h2><p>如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易添加该特性，然后再添加该特性。<br>重构前，先检查自己是否有一套可靠的测试集，这些测试必须有自我检视的能力。</p><blockquote><p>事实上很多时候，测试集都是被我们忽略的</p></blockquote><p>营地法则：保证你离开的时候代码库一定比原来的更加健壮。</p><p>什么是重构？根据重构这本书的定义，如果有人说他们的代码在重构过程中有一两天的时间是不可用的，基本上可以确定，他们在做的事情不是重构。</p><h2 id="何时重构"><a href="#何时重构" class="headerlink" title="何时重构"></a>何时重构</h2><p>事不过三法则（Rule of Three）：第一次做某件事情的时候只管去做，第二次做某件事情的时候会产生反感，但无论如何还是可以去做，第三次再做类似的事情，你就应该重构。</p><blockquote><p>在《代码精进之路》这本书中，也提到了这个原则。</p></blockquote><p>另外的一个时机是，每次要修改时，首先令修改很容易（警告：这件事有时候会很难），然后再进行这次的修改。</p><blockquote><p>比如，笔者最近在做一个长链接客户端 SDK，最初这个 SDK 功能很简单，我直接加功能即可，后面有一次当我要修改的时候，我发现这个 SDK 的修改已经变得异常复杂了，这个时候我知道我应该重构了。</p></blockquote><h2 id="重构法则"><a href="#重构法则" class="headerlink" title="重构法则"></a>重构法则</h2><p>这里对一些我们实际场景中遇到，但是通常会被我们忽视的一些法则进行列举。</p><h3 id="霰弹式修改"><a href="#霰弹式修改" class="headerlink" title="霰弹式修改"></a>霰弹式修改</h3><p>如果我们代码中的模块特别多，如果我们每次遇到一个变化都需要在不同的小模块中做许多小修改，我们所面临的坏味道就是霰弹式修改。<br>这个时候我们需要思考重构，最好我们不同的模块都是正交的。</p><h3 id="慎重注释"><a href="#慎重注释" class="headerlink" title="慎重注释"></a>慎重注释</h3><p>有的时候，我们写注释是因为这段对应的代码逻辑很糟糕。<br>因此当你感觉需要撰写注释的时候，请先尝试重构，试着将所有的注释变成多余。</p><h3 id="提炼变量"><a href="#提炼变量" class="headerlink" title="提炼变量"></a>提炼变量</h3><p>对于复杂语句，提炼变量可以增加可读性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;开始重构&quot;&gt;&lt;a href=&quot;#开始重构&quot; class=&quot;headerlink&quot; title=&quot;开始重构&quot;&gt;&lt;/a&gt;开始重构&lt;/h2&gt;&lt;p&gt;如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易添加该特性，然后再添</summary>
      
    
    
    
    
    <category term="读书笔记" scheme="https://z4ynadmin.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《架构整洁之道》-读书笔记</title>
    <link href="https://z4ynadmin.github.io/2021/12/26/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://z4ynadmin.github.io/2021/12/26/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2021-12-26T06:38:52.000Z</published>
    <updated>2022-11-04T07:11:09.559Z</updated>
    
    <content type="html"><![CDATA[<p>这本书之前刚工作的时候略有耳闻，不过当时简单翻阅了下，并没有什么共鸣，可能是编程经验太少导致，但最近我再重读这本书的时候，感觉之前自己或所在团队确实踩了不少类似的坑，也渐渐了解到，很多复杂的项目和工程背后，其实往往是一些最朴素的道理，软件工程的发展也并没有上层框架的发展那么快。</p><p>也因此，本篇博客作为一个读书笔记性质，可能有些地方也并非足够连贯。</p><h2 id="如何看待软件架构设计"><a href="#如何看待软件架构设计" class="headerlink" title="如何看待软件架构设计"></a>如何看待软件架构设计</h2><p>软件架构设计的终极目标：用最小的人力成本来满足构建和维护该系统的需求。</p><p>很多时候，对于一个系统，一开始我们的开发效率接近 100%，然而伴随产品的每次发布，生产力直线下降。工程师的大部分时间都是消耗在对现有系统的修修补补上面，而不是真正完成实际的功能。拆东墙补西墙，周而往复。公司需要的人力成本也因此变多了，但是效益却没有提升。</p><p>初级工程师总是会犯的一个问题是：持续低估良好的设计，整洁的代码的重要性，并且普遍采用一种话术来欺骗自己：我们可以未来在重构代码，产品上线最重要。而实际上，产品上线之后疲于应付新需求已经很累了，就很难有重构的时机。</p><p>实际上，一般软件开发都会被设计成如下三个阶段，这可能并没有错：</p><ol><li>先让代码工作起来</li><li>试图让它变好：通过优化和重构，让人更好地理解代码，并且适应新需求。</li><li>试着让它运行的更快</li></ol><p>所以，我们确实需要理解整洁架构的重要性，避免我们在 1 和 2 循环往复。</p><p>软件设计的第一条原则：不管是为了可测试性还是其他什么东西——<strong>是不变的，就不要依赖于多变的东西。</strong></p><h2 id="软件系统"><a href="#软件系统" class="headerlink" title="软件系统"></a>软件系统</h2><p>软件系统的价值维度：行为和架构。</p><p><strong>变更的实施难度应该和变更的范畴成等比关系，而与变更的具体行为无关</strong>。</p><blockquote><p>有的时候，产品经理会表示，我就改一个小点，为什么需要几天时间？开发人员会找一大堆理由，通常不会提及架构的不合理性。实际上这种现象在我毕业入职的第一家公司时有发生。</p></blockquote><h2 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h2><p>目前，我们主要有三个编程范式：结构化编程，面向对象编程，函数式编程。这些编程范式都是在 20 世纪被提出来的，而且在有限的时间中估计也不会新增编程范式了。</p><ul><li>结构化编程：if/then/else 和 do/while/util</li><li>面向对象编程</li><li>函数式编程：值不可变，对赋值进行了限制和规范</li></ul><p>三个编程范式，分别限制了 goto 语句、函数指针和赋值语句的使用。</p><h3 id="结构化编程"><a href="#结构化编程" class="headerlink" title="结构化编程"></a>结构化编程</h3><p>程序员可以用代码将一些已经证明可用的结构串联起来，只要自行证明这些额外代码是正确的，就可以推导出整个程序的正确性。</p><p>goto 语句，让我们的程序很难被分成这种小块。</p><p>关于验证：科学理论和科学定律的特点：他们可以被证伪，但是没有办法被证明，实际上现有的编程大部分也采用了这种理念，我们没用使用完整的形式化证明，而是使用测试用例，测试没有问题后，即发布到线上。</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul><li>封装、继承、多态都不是面向对象创造出来的，但是确实使用起来更方便了。</li><li>依赖反转也通常是面向对象的特点。</li><li>独立部署：当某个组件的源代码需要修改，仅仅需要重新部署该组件即可，不需要修改其他组件。</li></ul><p><strong>面向对象编程就是以多态为手段来对源代码中的依赖关系进行控制的能力，这种能力让软件架构师能够构建出某种插件结构，让高层策略性的组件和底层实现的组件相分离，底层组件可以被编译成插件，实现独立于高层组件的开发和部署。</strong></p><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><ul><li>所有的竞争问题、死锁问题、并发更新问题都是由可变变量导致的，如果变量永远不能被篡改，那就不可能产生竞争或并发更新的问题。如果锁的状态是不可变的，那就永远不会产生死锁问题。</li><li>一个个架构设计良好的应用程序应该将状态修改的部分和不需要修改状态的部分隔离承担度的组件，然后通过合适的机制保护可变量。</li><li>软件架构师应该着力于将大部分处理逻辑都归于不可变组件中，可变状态组件的逻辑越少越好。</li></ul><p>一种函数式编程理念的开发方式：<br>事件溯源：我们只存储事务记录，不存储具体状态，当需要计算具体状态的时候，我们只需要重头开始计算所有的事务即可。同时，我们也把 CURD 变成了 CR。</p><h2 id="SOLID-原则"><a href="#SOLID-原则" class="headerlink" title="SOLID 原则"></a>SOLID 原则</h2><p>我们为软件构建中层结构的主要目标：</p><ol><li>使软件可容忍被改动。</li><li>使软件更容易被理解。</li><li>构建可在多个软件系统中复用的组件。</li></ol><p>SOLID 原则 分为以下几点：</p><ul><li>SRP：单一职责原则，任何一个软件模块都应该有且只有一个被修改的原因。避免多人为了不同的目的修改同一份原代码文件。</li><li>OCP：开放封闭原则，通过新增代码来修改原有的行为，而非只靠修改源代码。</li><li>LSP：里氏替换原则，组件方便被替换，每一处使用父类对象的地方，可以使用其子类对象进行替换，而保持其行为不变。</li><li>ISP：接口隔离原则，避免不必要的依赖。</li><li>DIP：依赖反转原则，高层代码不应该依赖底层细节。如果我们想要设计一个灵活的系统，在源代码层次的依赖关系中就应该多引用抽象类型，而非具体实现。<ul><li>优秀的软件架构师会花费很大力气来设计接口，以减少未来对其进行的改动。毕竟在不修改借口的情况下为软件增加新的功能是软件设计的基础常识。</li></ul></li></ul><blockquote><p>实际上我们在实现 TS 库代码的时候经常用到 DIP，比如我们底层代码需要用到上层的一个功能，我们通常定义一个抽象类或者抽象函数，然后由上层来实现，这种场景即是 DIP。<br>例如，在我们写一个库的时候，通常会定义一个抽象，然后由外层传入实现这个 log，而不是在库代码中直接依赖某种 log 实现（可以有一个默认的实现），这个即是 DIP 的一个运用。</p></blockquote><h2 id="组件构建原则"><a href="#组件构建原则" class="headerlink" title="组件构建原则"></a>组件构建原则</h2><p>组件是软件的部署单元。</p><ul><li>REP：复用/发布原则：软件复用的最小粒度应等同于其发布的最小粒度。</li><li>CCP：共同闭包原则：我们应该将那些会同时修改，并且为相同目的而修改的类放到同一个组件中，而将不会同时修改，并且不会为了相同目的而修改的那些类放到不同的组件中。<ul><li><strong>对于大部分项目来说，可维护性的重要性远远大于复用性</strong>（精髓所在，以前一直觉得复用重要，但回头想想，对于一个项目而言，维护成本才是最直观的指标，这里设计修改所需要的人力成本，最终还是利益如何最大化的问题）</li></ul></li><li>CRP：共同复用原则：实际上是 LSP 原则的一个普适版，LSP 原则是建议我们不要依赖带有不需要函数的类，CRP 原则则是建议我们不要依赖带有不需要的类的组件。</li></ul><p>REP 和 CCP 是粘合性原则，他们会让组件变得更大，而 CRP 是排除性原则，它会尽量让组件更小。</p><p>组件耦合原则：</p><ul><li>无依赖环原则：整体依赖应该是一个有向无环图。</li><li>稳定依赖原则：<strong>依赖关系必须要指向更稳定的方向。</strong>我们可以通过组件的依赖和被依赖的关系计算它的位置稳定性。</li><li>稳定抽象原则：一个组件的抽象化程度应该与其稳定性保持一致。稳定的组件应该是抽象的，那么它的稳定性就不会影响到扩展性。</li></ul><h2 id="软件架构流程"><a href="#软件架构流程" class="headerlink" title="软件架构流程"></a>软件架构流程</h2><p>整体包括：运行、维护、开发、部署</p><p>什么是软件架构师？软件架构师实际上应该是能力最强的一群程序员，他们通常会在自身承接编程任务的同时，逐渐引导整个团队向一个能够最大化生产力的系统设计方向演进。所以我们有时候误以为架构师就不写代码了，这当然是错的。</p><p>软件架构设计的三个工作：组件的切分，组件的组合，以及组件的相互通信。</p><p>软件架构设计的终极目标：最大化程序员的生产力，最小化系统的总运营成本。</p><p>关于部署：一般一个系统的部署成本越高，它的可用性就越低</p><blockquote><p>例如在系统早期开发中，我们可能会决定采用某种微服务架构，但当我们实际部署这个系统的时候，我们就会发现微服务的数量已经庞大到令人生畏，这也就是笔者之前所在公司遇到的问题：一开始通过 golang 微服务实现整个系统，后面决定私有化部署后，迁移成本巨大，不得不进行了微服务的合并。</p></blockquote><p>运行：<strong>对于一个因架构设计糟糕而效率低下的系统，我们通常只需要增加更多的存储器与服务器，就能够让它圆满的完成任务。另外，硬件也远远比人力便宜，这也是软件架构对系统运行的影响远远没有它对开发、部署、维护的影响那么深刻的原因</strong><br>笔者现在确实应该意识到这个问题。</p><p>基于以上设计的架构：UI 界面 - 系统独有的业务能力 - 领域普适的业务能力 - 数据库</p><p>重复：<em>架构师经常会钻进一个牛角尖：害怕重复</em>。虽然软件代码编写的原则是 <code>don&#39;t repeat yourself</code>，但是有的时候，对于两个后期发展偏差很大的组件，如果只是存在一些暂时的重复，是我们完全可以容忍的。我们应该根据实际情况来决定是否要重复。</p><h2 id="划分边界"><a href="#划分边界" class="headerlink" title="划分边界"></a>划分边界</h2><p>软件开发技术发展史，就是一个如何想法设法方便增加插件，从而构建一个可扩展，可维护的系统架构的故事，系统的核心业务逻辑必须和其他组件隔离，保持独立，而这些其他组件要么是可以去掉的，要么是有多重实现的。<br>同时，插件部分的变更实际上不应该影响系统核心逻辑的变更。</p><blockquote><p>这里举例：比如说当我们设计一个多节点 server，它依赖一个分布式存储系统，我们不应该在 server 中把这个分布式存储系统默认为 redis, 而应该定义接口能力即可。</p></blockquote><p>如何分层：本质上，所有的软件系统都是一组策略语句的集合。我们需要将这些策略彼此分离，并且将它们按照变更的方式进行重新分组。其中变更的原因，时间和层次相同的策略应该分到一个组件中。反之，变更原因、时间和层次不同的策略应该分属不同的组件。最终它们是一个有向无环图。</p><h2 id="整洁架构"><a href="#整洁架构" class="headerlink" title="整洁架构"></a>整洁架构</h2><ul><li>六边形架构</li><li>DCI 架构</li><li>BCE 架构</li></ul><p>这些架构通常有以下特点：</p><ol><li>独立于框架</li><li>可被测试：这些系统的业务逻辑可以脱离 UI、数据库、Web服务以及其他外部元素来进行测试。</li><li>独立于 UI，并且比较方便地在不改动业务逻辑的情况下改动 UI</li><li>独立于数据库，以及独立于其他外部机构</li></ol><p>谦卑对象模式：</p><p>谦卑对象的解读：我们可以将软件模块分为两组，一组是谦卑组，另外一组不是。谦卑组的模块通常比较难写代码进行测试，比如 GUI，这部分代码应该越简单越好。</p><p>门户模式：Facade Pattern<br>外部只能看到 Facade，然后 Facade 内部的 implement 可以有一个或者多个。</p><blockquote><p>这种模式在我们重构项目的时候挺有用的，我们可以实现一个 Facade 类，然后默默把里面的实现灰度或者直接换掉。</p></blockquote><h2 id="服务和架构"><a href="#服务和架构" class="headerlink" title="服务和架构"></a>服务和架构</h2><p>实际上，服务本身只是一种比函数调用成本稍微高的，分割应用程序的一种形式，与数据库无关。</p><p><strong>服务真的解耦了么？因为通常服务不能彼此访问变量，我们会认为这种设计自然就解耦了。但实际上，任何形式的共享数据都会导致强耦合，比如它们依赖同一种数据结构、同一个 schema。而且在这种情况下，它们的 dev ops 也并不是独立的。</strong></p><hr><p>&lt;完&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这本书之前刚工作的时候略有耳闻，不过当时简单翻阅了下，并没有什么共鸣，可能是编程经验太少导致，但最近我再重读这本书的时候，感觉之前自己或所在团队确实踩了不少类似的坑，也渐渐了解到，很多复杂的项目和工程背后，其实往往是一些最朴素的道理，软件工程的发展也并没有上层框架的发展那么</summary>
      
    
    
    
    
    <category term="读书笔记" scheme="https://z4ynadmin.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="架构" scheme="https://z4ynadmin.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>React Conf 2021 内容概要</title>
    <link href="https://z4ynadmin.github.io/2021/12/08/ReactConf2021/"/>
    <id>https://z4ynadmin.github.io/2021/12/08/ReactConf2021/</id>
    <published>2021-12-08T14:59:00.000Z</published>
    <updated>2022-11-04T07:11:09.552Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://zhuanlan.zhihu.com/p/447103166">https://zhuanlan.zhihu.com/p/447103166</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原文：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/447103166&quot;&gt;https://zhuanlan.zhihu.com/p/447103166&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="React" scheme="https://z4ynadmin.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>PC 开发技术选型：Electron 不是银弹</title>
    <link href="https://z4ynadmin.github.io/2021/09/16/electron%E5%8F%AF%E8%83%BD%E4%B8%8D%E6%98%AF%E4%BD%A0%E7%9A%84%E8%A7%A3%E8%8D%AF/"/>
    <id>https://z4ynadmin.github.io/2021/09/16/electron%E5%8F%AF%E8%83%BD%E4%B8%8D%E6%98%AF%E4%BD%A0%E7%9A%84%E8%A7%A3%E8%8D%AF/</id>
    <published>2021-09-16T07:01:35.000Z</published>
    <updated>2022-11-04T07:11:09.553Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.electronjs.org/docs">Electron</a> (类似的还有 nw.js）是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入了 Chromium 和 Node.js。</p><p>也就是说，我们几乎可以使用纯 web 技术，来创建跨平台的 windows 和 macOS 的原生应用，并通过 Node.js addon 能力接入 native 模块。目前市面上，也有一大批知名的应用是使用 Electron 开发的，比如：VS Code、Atom、Microsoft Teams 等（<em>在 macOS 上面一个简单的判断应用是否使用了 Electron 的办法：在应用的 Contents/Frameworks 里面搜索是否有 Electron Framework.framework</em>）。</p><p>但实际上，这篇文章是希望你在选用 Electron 框架前，需要进行慎重的考虑和评估。国内有很多公司，包括一些一线互联网公司的项目是一开始为了快速迭代选择了 Electron，后续实在无法进一步优化，全部推到重来，这实际上反而不利于整体的项目迭代。</p><h1 id="架构选型"><a href="#架构选型" class="headerlink" title="架构选型"></a>架构选型</h1><p>一般来说，笔者认为有以下几个场景，不适合使用 Electron 进行开发：</p><h2 id="1-无页面或者少量页面的应用"><a href="#1-无页面或者少量页面的应用" class="headerlink" title="1. 无页面或者少量页面的应用"></a>1. 无页面或者少量页面的应用</h2><p>这一点很好理解，Electron 的便利性主要体现在页面相关的开发，如果你的应用几乎没有页面，比如只在顶部状态栏区域有一个按钮，显然就没有必要使用 Electron，直接使用原生的技术栈即可。</p><h2 id="2-对安装包体积限制较为严格的应用"><a href="#2-对安装包体积限制较为严格的应用" class="headerlink" title="2. 对安装包体积限制较为严格的应用"></a>2. 对安装包体积限制较为严格的应用</h2><p>Electron 由于自身携带的基础设施，导致即使你的业务代码不多，初始安装包也会比较大（毕竟接近一个浏览器的大小），在没有你的业务代码的情况下，未经优化的安装包达到了 60MB 左右，而且通常你需要把 node_modules 一起打进去，所以即使你的业务并不复杂，也很容易产生一个接近 100MB 的安装包。</p><p>因此，如果你的业务需要比较极致的包体积优化，那么 Electron 可能并不是一个合适的选择。</p><h2 id="3-多窗口应用"><a href="#3-多窗口应用" class="headerlink" title="3. 多窗口应用"></a>3. 多窗口应用</h2><p>Electron 的进程模型为一个主进程 + 若干渲染进程，每一个渲染进程用于展示一个页面，<strong>即使你的页面是 Hello World，内存占用也达到 50 MB 左右</strong>。</p><p>也就是说，如果你的应用需要同时展示多个窗口，那么就需要多个渲染进程，这样整体的内存占用就会上涨很多，而实际上我们使用原生或者其他的类 cef 的方案，是可以做到一个进程对应多个窗口的。</p><h2 id="4-性能消耗较高并且需要高度定制优化的应用：比如视频类应用"><a href="#4-性能消耗较高并且需要高度定制优化的应用：比如视频类应用" class="headerlink" title="4. 性能消耗较高并且需要高度定制优化的应用：比如视频类应用"></a>4. 性能消耗较高并且需要高度定制优化的应用：比如视频类应用</h2><p>Electron 基于 web 架构，所以使用 Electron 开发的应用性能一般来说和 web 比较接近，当然，我们可以通过 Node.js addon 加持的方式让部分场景下性能更高（比如直接使用 c++ 实现一些计算密集型的模块，或者独立出一个非 UI 进程，来处理非 UI 逻辑），不过页面 UI 相关的还是会受限制于 web 的天花板。</p><p>所以，一般来说，以下两种情况可能不适用于 Electron：</p><ol><li><p>在 web 场景下，UI 元素操作比较卡顿，达到瓶颈，必须采用性能更高的原生 UI。不过我建议<strong>不要轻易下这个结论</strong>，一般情况下这种性能问题都是写的代码不够极致，建议先从 web 的角度进行性能优化（比如，长列表场景我们可以<a href="http://niexiaotao.cn/2021/09/04/%E9%80%9A%E8%BF%87%E5%8E%8B%E7%BC%A9%E5%90%88%E6%88%90%E5%B1%82%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD/">通过压缩合成层优化性能</a>来数十倍地提高性能）。</p></li><li><p>对某一项技术有深度依赖，而这项技术在 web 方面存在性能上的天花板。事实上这种情况也并不多见，其中一个合理的场景是视频相关的应用，比如视频会议，或者视频播放器，这类由于 Chrome 本身的渲染流水线的限制，使用 video 标签或者使用 WebGL 都会存在一些性能问题，这个时候我们需要更深入的去进行相关能力的定制，就需要从 Electron 的框架中跳脱出来，或者针对 Electron 进行二次开发。</p></li></ol><blockquote><p>关于 WebGL: 实际上很多 web 开发者会把 WebGL 当作部分场景下性能优化的银弹，但实际上 WebGL 目前存在诸多困境：WebGL 1.0 虽然已经普及，但是其作为 OpenGL ES 2.0 的子集，性能上已经并不特别适用现代硬件架构；而 WebGL 2.0 目前仍然在普及中并且各家厂商意见无法一致；Web GPU 可能是一个更好的解决方案，底层直接对接 D3D12、metal、vulkan 等更底层更先进的图形框架，但目前成熟度不高。</p></blockquote><p>如果你的应用在经过以上分析之后，认为仍然可以使用 Electron 进行开发，那么恭喜你拥有了一个如此高效率的开发方案（如果不行，建议你可以选择其他的解决方案，比如 <a href="https://www.qt.io/">QT</a>）。</p><p>当然在此基础上，我们仍然需要进行充足的性能优化和稳健的架构设计，来让我们应用的可靠性变得更高。</p><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>和 web 不同的是，我们的 native 应用需要更加关注如下三个指标：</p><h2 id="1-cpu"><a href="#1-cpu" class="headerlink" title="1. cpu"></a>1. cpu</h2><p>cpu 占用相关的问题，我们在 web 技术栈中一般也会关注，不过更多的是关注函数的调用耗时，是否存在同步调用的耗时过长导致卡顿等问题。</p><p>而在桌面应用程序的场景中，我们需要从整个应用的维度关注 cpu 消耗，并且需要更加重视。</p><p>另外一个原因是，在网页场景中，页面的 cpu 占用通常不会特别直观地被用户发现（因为系统层面通常只会体现在浏览器占用 cpu 较多），而在现在的原生场景，用户可以直接在任务管理器中看到我们的应用，如果我们的应用持续有一个较高的 cpu 占用，就会比较容易被用户发现，甚至触发系统告警提示强杀应用，这对我们应用的口碑也是一个比较负面的影响。</p><h2 id="2-内存"><a href="#2-内存" class="headerlink" title="2. 内存"></a>2. 内存</h2><p>在桌面应用程序中，内存的使用方式有了一个明显的变化：</p><p>原有的 web 页面，通常是用完即走，而对于 native 应用用户一般会打开很久，这也就意味着我们如果一旦产生内存泄漏或者内存占用比较高的情况，对用户的影响是持续并且被不断放大的。</p><p>对于 cpu 和内存的分析，我们可以通过以下方式：</p><ol><li>开发阶段通过 visual studio 或 instruments 来详细分析我们开发的功能的 cpu 和内存分配情况，发现问题。</li><li>测试发布阶段通过第三方内存分析工具，流程化的分析 cpu 和内存占用并产出报告。</li><li>线上阶段持续监控 cpu 和内存消耗情况，并且上报数据进行统计和监控告警。</li></ol><h2 id="3-crash-率"><a href="#3-crash-率" class="headerlink" title="3. crash 率"></a>3. crash 率</h2><p>实际上在前端领域基本上没有 “crash” 这个说法，不过对于 native 应用来说，即使我们的应用是完全采用前端技术栈，也可能存在 crash (crash 在 Electron 的代码），一般这个时候用户的体验是闪退，相对来说算是严重影响用户体验的问题，因此值得我们足够的重视。</p><p>对于 crash 问题我们应该做好以下三点：</p><ol><li>运行时 crash 监听机制，一般是 sentry 或者直接使用其依赖的 crash_pad。</li><li>符号管理机制，管理我们原生模块，和我们用到的 Electron 对应版本的符号。</li><li>运行时 crash 上报告警机制。</li></ol><h1 id="架构优化"><a href="#架构优化" class="headerlink" title="架构优化"></a>架构优化</h1><p>除了上述性能指标和监控手段，我们可以通过一定的架构优化，来增强系统的可靠性。</p><h2 id="通过-Node-js-addon-或者独立进程的方式原生实现非-UI-内容"><a href="#通过-Node-js-addon-或者独立进程的方式原生实现非-UI-内容" class="headerlink" title="通过 Node.js addon 或者独立进程的方式原生实现非 UI 内容"></a>通过 Node.js addon 或者独立进程的方式原生实现非 UI 内容</h2><p>这里的作用主要是希望能够借助原生模块的高性能优化 cpu 的占用。</p><p>Electron 让我们开发 ui 相关的页面变得非常高效，但是一些逻辑部分，或者和操作系统进行交互的部分，我们还是需要原生开发的手段，毕竟即使使用了 Node.js，也无法直接进行系统调用。</p><p>这里我们可以采用 Node.js addon 的方式或者独立进程+进程间通信的方式，两者的好处分别是：</p><p>addon：</p><ol><li>方便进行内存共享。</li></ol><p>独立进程：</p><ol><li>通常会增加可靠性，独立进程挂掉后可以单独重启，不影响用户界面。</li><li>需要防止大块的内存重复占用，可以通过共享内存等方式来进行优化。</li></ol><h2 id="减少或者禁止在渲染进程使用-remote"><a href="#减少或者禁止在渲染进程使用-remote" class="headerlink" title="减少或者禁止在渲染进程使用 remote"></a>减少或者禁止在渲染进程使用 remote</h2><p>有的时候，即使 electron 的技术选型适合你的项目，但如果滥用 remote 也会造成整个应用的大量不稳定与卡顿。</p><p>实际上，我们可以通过阅读 electron 的源代码发现，remote 模块只是对 IPC 消息的同步封装，方便渲染进程调用主进程的对象和方法，而不必显式发送消息进行进程间通信。所以，由于其屏蔽了内部的进程间通信，在调用的时候基本无感主进程的存在和 IPC 的风险，但事实上这却有卡顿甚至卡死渲染进程的风险。</p><p>另外，去掉 remote 还有另外一个好处，就是方便我们项目的 PC 版本和 web 版本进行同构，具有更高的可维护性。</p><p>所以针对一般的项目，笔者建议能禁用就禁用 remote，规避此隐患。</p><h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><p>我们可以在代码编写和打包的过程中，做一些其他的优化，在这里，大部分前端的优化比如动态加载、代码分割、图片缓存等大多也都适用 electron 的情况，除此之外，还有一些优化则是：</p><ol><li><p>避免重复打包：</p><ul><li><strong>避免 node_modules 和 webpack 重复的打包和引入</strong>，对于 webpack 我们可以使用 webpack-bundle-analyzer 来分析打包体积进行优化</li><li>减少无关文件的打包，可以通过配置针对 electron-builder 的 config 去除无关内容打包，同时可以使用 <a href="https://github.com/tj/node-prune">node-prune</a> 来去除无用的 node_modules 小文件。</li></ul></li><li><p><strong>v8-code-cache</strong>: </p><ul><li>可以使用 <a href="https://github.com/zertosh/v8-compile-cache">v8-compile-cache</a> 来进行一定的编译优化</li></ul></li><li><p>更多可以参考 VSCode 的相关分享：<a href="https://www.youtube.com/watch?v=r0OeHRUCCb4">https://www.youtube.com/watch?v=r0OeHRUCCb4</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.electronjs.org/docs&quot;&gt;Electron&lt;/a&gt; (类似的还有 nw.js）是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入了 Chromium 和 Node.js。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="前端综合" scheme="https://z4ynadmin.github.io/tags/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>web 页面内存分析与生产环境禁用 console</title>
    <link href="https://z4ynadmin.github.io/2021/09/04/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%A6%81%E7%94%A8console%E7%9A%84%E6%84%8F%E4%B9%89/"/>
    <id>https://z4ynadmin.github.io/2021/09/04/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%A6%81%E7%94%A8console%E7%9A%84%E6%84%8F%E4%B9%89/</id>
    <published>2021-09-04T11:15:01.000Z</published>
    <updated>2022-11-04T07:11:09.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们在开发前端页面中，建议在生产环境中将所有的 console 禁用，并通过自定义的日志函数进行日志输出，即使无法禁用，也需要自定义文本过滤函数，严格控制 console 的输出。</p><p>但实际上，笔者经历的项目中很多都没有办法做到这一点，虽然我们知道，禁用 console 的主要原因除了信息泄漏的风险外，还有就是 console 打印的内容无法被内存回收。但仍然总是会有一些同学对禁用 console 的必要性表示质疑，在本篇文章中，本文通过两个实际遇到的比较严重的例子，来解释禁用 console 的必要性。</p><blockquote><p>出于保密性考虑，例子本身已经脱敏，本文使用示例代码模拟原始场景。</p></blockquote><h2 id="页面内存"><a href="#页面内存" class="headerlink" title="页面内存"></a>页面内存</h2><p>在具体例子讲解之前，我们需要先对页面内存有一个认知，在前端开发中，我们虽然开发的只是在 Chrome 等浏览器中浏览的页面，但是对页面的 cpu 和 内存占用也需要时刻保持关注。</p><p>cpu 和 内存一般是针对进程级别，chrome 的进程模型比较复杂，一般情况下，我们可以认为同域的页面有比较大的概率进行进程复用。</p><p>Chrome 提供了一些手段，让我们可以监控页面的 cpu 和内存，例如：</p><p>Performance Monitor 可以让我们直观地监测页面的 cpu、js heap 的分配情况等：</p><p><img src="/img/chrome_monitor.png" alt="chrome_monitor"></p><p>Chrome 自身提供了一个任务管理器（More Tools -&gt; Task Manager），可以让我们关注各个页面的性能情况：</p><p><img src="/img/chrome_task_manager.png" alt="chrome_task_manager"></p><p>除了实时监控以外，Chrome DevTools 的 Memory 等 tab 也可以让我们对内存占用进行取样分析，以及内存泄漏分析：</p><ul><li>一般来说，我们可以通过对两次 heap snapshot，然后搜索关键变量的数目与引用关系是否符合预期，来证明是否存在内存泄漏。</li><li>除此之外，我们使用 WeakMap 来跟踪我们的实例，也可以辅助进行一定的内存泄漏分析。</li></ul><h2 id="使用-console-log-打印-dom-元素造成死循环-OOM"><a href="#使用-console-log-打印-dom-元素造成死循环-OOM" class="headerlink" title="使用 console.log 打印 dom 元素造成死循环 OOM"></a>使用 console.log 打印 dom 元素造成死循环 OOM</h2><p>之前笔者负责的一个页面，在某个版本出现了一个问题：打开页面后不久，在什么操作也没有做的情况下直接卡死无响应。</p><p>一般来说，js 导致网页无响应的可能性并不多，我们首先怀疑是因为死循环导致的。</p><p>不过我们通过对比上次和这一次的代码，发现变动极小（实际上，我们一开始都忽略了 console.log），我们通过在 Chrome 的 devTools 里面打断点，最终定位发现是卡死在第三方库 sentry 的 console.log 中。</p><p>最终我们定位出真正的原因：其中一处 try catch 在 catch 到错误之后，会 console.log 打印包括 dom 在内的一些内容，而我们使用的 console.log 被 sentry 进行了覆盖，它的覆盖方法大致如下（这个确实有点坑，以至于我们直接查看 console.log 仍然是 [native code]， 不过最新版本的 Chrome 这个代码已经不能完全 work）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> __native_console = <span class="built_in">console</span>.log;</span><br><span class="line"><span class="built_in">console</span>.log = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归遍历各个属性</span></span><br><span class="line">  __native_console(...arguments);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log.prototype.__native_console = __native_console;</span><br><span class="line"><span class="built_in">console</span>.log.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.__native_console) <span class="keyword">return</span> <span class="built_in">this</span>.__native_console.toString();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 2021.09 @niexiaotao 补充一下最新的实现</span></span><br></pre></td></tr></table></figure><p><strong>这里之所以死循环，是因为 React 中 FiberNode 是 Dom 的其中一个属性，console.log 递归遍历到了 FiberNode，其本质是一个双向链表，最终造成无限递归死循环</strong>。</p><p>我们可以比较方便的随便找个 React 项目验证这一点：</p><p><img src="/img/chrome_fiber.png" alt="React Fiber"></p><h2 id="detached-dom-过多导致页面内存持续上涨"><a href="#detached-dom-过多导致页面内存持续上涨" class="headerlink" title="detached dom 过多导致页面内存持续上涨"></a>detached dom 过多导致页面内存持续上涨</h2><p>另外笔者接触到的一个比较严重的问题，是之前某项目的一个页面，随着使用时间增加，页面的内存使用量快速持续增加，最终导致卡顿和崩溃。</p><p>这个问题的定位过程也比较艰辛，最终发现其中的一个主要原因是 <strong>console.log 打印了 dom 节点，导致 detached dom 持续增多并且无法被回收，最终导致严重问题</strong>。</p><p>关于 detached dom 的问题我们可以使用<a href="http://niexiaotao.cn/2021/09/04/%E9%80%9A%E8%BF%87%E5%8E%8B%E7%BC%A9%E5%90%88%E6%88%90%E5%B1%82%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD/">通过压缩合成层优化性能</a> 这里的 demo，简单修改：</p><p>将原本需要挂载到 dom 的节点直接进行打印：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; totalListCount; i += <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> fragment = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">  fragment.classList.add(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">  fragment.innerHTML = <span class="string">`&lt;p&gt;this is the <span class="subst">$&#123;i&#125;</span> element&lt;/p&gt;`</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(fragment);</span><br><span class="line">  <span class="comment">// list.appendChild(fragment);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们很容易看到这样就产生了 500 个 detach 节点，并且在页面的生命周期内，无法进行释放：</p><p><img src="/img/chrome_detach_console.png" alt="detach console"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上，在生产环境使用 console.log 造成的问题远不止上面的两例，而且这类问题通常排查起来都会比较艰难，因此，建议大家落实在生产环境禁用 console。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;我们在开发前端页面中，建议在生产环境中将所有的 console 禁用，并通过自定义的日志函数进行日志输出，即使无法禁用，也需要自定义文本过滤</summary>
      
    
    
    
    
    <category term="javascript" scheme="https://z4ynadmin.github.io/tags/javascript/"/>
    
    <category term="性能优化" scheme="https://z4ynadmin.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>通过优化合成层优化性能</title>
    <link href="https://z4ynadmin.github.io/2021/09/04/%E9%80%9A%E8%BF%87%E5%8E%8B%E7%BC%A9%E5%90%88%E6%88%90%E5%B1%82%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD/"/>
    <id>https://z4ynadmin.github.io/2021/09/04/%E9%80%9A%E8%BF%87%E5%8E%8B%E7%BC%A9%E5%90%88%E6%88%90%E5%B1%82%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD/</id>
    <published>2021-09-04T05:15:01.000Z</published>
    <updated>2022-11-04T07:11:09.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Web 性能优化特别是长列表滚动优化是一个老生常谈的问题，一般我们的思路是通过虚拟滚动、GPU 加速、fragment 复用等方式优化性能。</p><p>在本篇文章中，主要介绍一个压缩合成层的思路来进行性能优化，关于合成层的文章网上也有一些（附录部分有列出），不过大部分文章会对合成层创建的原因进行冗长的介绍，本文会跳过这些部分。原因是我们通过 devTools 可以比较方便的针对具体情况分析创建合成层的原因，另外一个原因是 blink 已经把创建合成层的原因写到了一个文件中（<a href="https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/platform/graphics/compositing_reasons.cc">传送门</a>），我们直接参考就行，也没有必要去全都记住。</p><h2 id="合成层是什么"><a href="#合成层是什么" class="headerlink" title="合成层是什么"></a>合成层是什么</h2><p>对于 blink 渲染引擎的渲染流程，大致可以分为以下几个阶段：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D<span class="function"><span class="title">om</span> Tree -&gt;</span> L<span class="function"><span class="title">ayout</span> Object -&gt;</span> P<span class="function"><span class="title">aint</span> Layer -&gt;</span> G<span class="function"><span class="title">raphics</span> Layers Tree -&gt;</span> Paint</span><br></pre></td></tr></table></figure><p>我们对以上过程进行一个简述：</p><ul><li>Dom Tree 到 Render Tree 这个过程，基本是一一对应的，除了一些 display:none 的元素。</li><li>Layout Object 会按照一定条件创建 Paint Layer。</li><li>Paint Layer 在到 Graphics Layer 的过程中，会创建合成层（Composite Layer），会对应独立的 Graphics Layer。</li><li>Graphics Layer 会把结果渲染到纹理，最终通过 Chrome 的渲染层以及系统进行上屏。</li></ul><p>实际上我们可以发现，合成层的多少会比较影响我们的渲染性能，合成层比较多的情况下，当我们对页面进行交互（比如滚动），触发重新渲染，就会有卡顿的风险。</p><h2 id="分析合成层"><a href="#分析合成层" class="headerlink" title="分析合成层"></a>分析合成层</h2><p>Chrome 的 DevTools 工具可以让我们比较方便地进行合成层分析，例如我们通过一个 demo 来进行分析：</p><p><img src="/img/composite_reason.png" alt="合成层示例"></p><p>在上图中，我们会发现这个 demo 的合成层比较多，我们点进去可以查看到是因为 overflow 导致创建了新的合成层。</p><p>也就是说，对该 demo 而言我们可以尝试在这些 Demo 中去掉或者修改 overflow 的相关设置，从而进行合成层优化。</p><h2 id="优化合成层"><a href="#优化合成层" class="headerlink" title="优化合成层"></a>优化合成层</h2><p>我们尝试去掉 <code>overflow: scroll;</code>。（ Demo 源代码会在本文最后给出）</p><p>然后我们设置页面的列表元素为 500 个，通过模拟页面持续滚动，来检查去掉前后的性能。</p><p>去掉前，cpu 保持在 50%+，这实际上已经是一个比较高的数值了：</p><p><img src="/img/composite_cpu_1.png" alt="合成层cpu"></p><p>去掉后，cpu 保持在 2% 左右：</p><p><img src="/img/composite_cpu_2.png" alt="去除合成层cpu"></p><p>我们可以看到，优化后有巨大的性能提升，这种量级的性能提升，会远超虚拟滚动等方案（其实我个人是不建议采用虚拟滚动的，非常难维护，而且你很难做到浏览器原生滚动的丝滑水准）。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0,minimal-ui:ios&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> &gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100vw</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">100vh</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">      <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">      <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.list</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">90vh</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">overflow</span>: scroll;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.li</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">border-bottom</span>: <span class="number">2px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">border-style</span>: solid;</span></span><br><span class="line"><span class="css">      <span class="attribute">border-color</span>: grey;</span></span><br><span class="line"><span class="css">      <span class="comment">/* overflow: scroll; */</span></span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> totalListCount = <span class="number">500</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> list = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.list&quot;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; totalListCount; i += <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> fragment = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="javascript">    fragment.classList.add(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line"><span class="javascript">    fragment.innerHTML = <span class="string">`&lt;p&gt;this is the <span class="subst">$&#123;i&#125;</span> element&lt;/p&gt;`</span>;</span></span><br><span class="line"><span class="javascript">    list.appendChild(fragment);</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> curr = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> renderScroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    curr += <span class="number">5</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (curr &gt;= totalListCount) curr = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">    list.children[curr].scrollIntoView();</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.requestAnimationFrame(renderScroll)</span></span><br><span class="line"><span class="javascript">  &#125;;</span></span><br><span class="line"><span class="javascript">  renderScroll();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参考：</p><ul><li>Compositing Layers: <a href="https://zhuanlan.zhihu.com/p/88288584">https://zhuanlan.zhihu.com/p/88288584</a></li><li>前端性能优化之 Composite: <a href="https://segmentfault.com/a/1190000015917498">https://segmentfault.com/a/1190000015917498</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;Web 性能优化特别是长列表滚动优化是一个老生常谈的问题，一般我们的思路是通过虚拟滚动、GPU 加速、fragment 复用等方式优化性能。</summary>
      
    
    
    
    
    <category term="性能优化" scheme="https://z4ynadmin.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>了解 StackOverFlow 上面最受欢迎的语言 Rust</title>
    <link href="https://z4ynadmin.github.io/2021/09/02/%E4%BA%86%E8%A7%A3%20StackOverFlow%20%E4%B8%8A%E9%9D%A2%E6%9C%80%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E8%AF%AD%E8%A8%80%20Rust/"/>
    <id>https://z4ynadmin.github.io/2021/09/02/%E4%BA%86%E8%A7%A3%20StackOverFlow%20%E4%B8%8A%E9%9D%A2%E6%9C%80%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E8%AF%AD%E8%A8%80%20Rust/</id>
    <published>2021-09-02T11:15:51.000Z</published>
    <updated>2022-11-04T07:11:09.556Z</updated>
    
    <content type="html"><![CDATA[<p>本文希望从宏观角度，来介绍和分析 Rust 语言。</p><p>Rust 是一门<strong>专注安全</strong>的现代系统编程语言，发布于 2015 年。</p><p>自从 2015 年发布起，Rust 就一直是 StackOverFlow 上面最受欢迎的语言，而且和第二名还能拉开不小的差距，例如最近两年的统计数据：</p><p><a href="https://insights.stackoverflow.com/survey/2020#most-loved-dreaded-and-wanted">2020</a>:<br><img src="/img/rust_2020.png" alt="2020_rust"></p><p><a href="https://insights.stackoverflow.com/survey/2021#most-loved-dreaded-and-wanted-language-love-dread">2021</a>:<br><img src="/img/rust_2021.png" alt="2021_rust"></p><p>接下来笔者通过性能、可靠性、生产力、面向前端友好等几个维度来介绍 Rust，之后会对 Rust 的部分重点语言特性进行介绍。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>首先作为一种编译型语言，可以直接将编译产物作为二进制可执行文件部署，无需随程序一起分发解释器和大量的依赖项，因此相对于 Python、Ruby 以及 Javascript 等解释型语言，会效率更高。</p><p>同时，Rust 提供了大量的零成本抽象（如泛型、async/await、迭代和闭包等），在保证开发效率的同时避免了运行时开销。</p><p>一般来说，Rust 的性能和 C/C++ 相似，无虚拟机，无 GC，运行时仅依赖 libc，<strong>在需要高性能场景中使用已经足够</strong>。</p><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>在一个 c++ 项目中，我们经常会遇到各类 crash，处理这些 crash 通常会花费大量的人力。</p><p>而在一个 Rust 项目中，如果规范使用基本上在编译阶段就可以避免几乎所有的 crash，也就是说，<strong>使用 Rust 的项目只要编译通过，就只有逻辑错误，不会再有 crash</strong>（自身使用了 unsafe 除外）。</p><p>Rust 之所以能做到这一点，得益于其设计的所有权、生命周期、Option 机制以及智能指针等，这一点我们在下文的语言特性中也会更详细地分开介绍。</p><blockquote><p>实际上，笔者现在负责的项目中 Rust 和 C++ 大约各有一半的代码，在这其中 Rust 几乎没有出现过 crash，而 c++ 基本上每双周（一个迭代）都会新增一些种类的 crash。</p></blockquote><h2 id="生产力"><a href="#生产力" class="headerlink" title="生产力"></a>生产力</h2><h3 id="代码开发效率"><a href="#代码开发效率" class="headerlink" title="代码开发效率"></a>代码开发效率</h3><p>得益于 Rust 的大量零成本抽象，以及 Rust 提供的高度灵活的宏机制，我们的代码开发效率还是比较高的。就笔者的体验而言，使用 Rust 完成功能的开发效率略低于 Typescript，但是远高于 c++（和 Typescript 相比，Rust 通常会需要花费额外的一些时间来解决编译问题，但是换来的是高性能和稳定性，我认为这是值得的）。</p><p>另外随着 Rust 语言的逐渐成熟，配套的 IDE 和编辑器（Clion、VSCode）也逐渐成熟，日常代码开发提示、以及代码调试等都非常方便。</p><h3 id="包管理系统"><a href="#包管理系统" class="headerlink" title="包管理系统"></a>包管理系统</h3><p>另外值得一提的是，Rust 的包管理系统非常强大，这一点我认为 Rust 也参考了 npm，包管理系统的使用体验也和 npm 比较接近，新增一个依赖，只需要在 Cargo.toml 配置文件中新增一行配置即可。方便的包管理系统，让我们可以方便地复用<a href="https://crates.io/">社区各类优秀的资源</a>。</p><p>相对来说，c++ 这类老牌语言的包分发和管理就会麻烦很多，甚至在一个项目内也会比较麻烦。</p><h3 id="现有资源的复用"><a href="#现有资源的复用" class="headerlink" title="现有资源的复用"></a>现有资源的复用</h3><p>这一点主要是 Rust 和 C/C++ 的互相调用，Rust 支持调用 C 接口和封装成 C 接口被其他语言所调用，因此对于现有的项目，如果可以提供一层 C 接口的封装，就会比较方便地被 Rust 直接调用。</p><h2 id="面向前端友好"><a href="#面向前端友好" class="headerlink" title="面向前端友好"></a>面向前端友好</h2><p>我认为 Rust 面向前端友好主要体现在两个方面：</p><h3 id="虽然学习路线陡峭，但和-Typescript-相近点较多"><a href="#虽然学习路线陡峭，但和-Typescript-相近点较多" class="headerlink" title="虽然学习路线陡峭，但和 Typescript 相近点较多"></a>虽然学习路线陡峭，但和 Typescript 相近点较多</h3><p>很多人劝退 Rust 理由之一是其学习曲线陡峭，但是实际上前端同学学习 Rust 会比学习 C++ 容易的多，一方面，Rust 的很多机制（async/await、类的设计、包管理）等都和 Typescript 有相似之处，另外一方面写 Rust 只要编译能够通过基本上能够保证你代码质量的下限，也就是说基本上可以上线生产环境。而 C++ 新手写出来的代码通常会有各种 crash 隐患，而且排查通常较为困难，导致容易背锅，这一点来说对新手非常不友好。</p><h3 id="面向-WASM-友好"><a href="#面向-WASM-友好" class="headerlink" title="面向 WASM 友好"></a>面向 WASM 友好</h3><p>对于 WebAssembly，笔者并不推荐 AssemblyScript，因为其虽然是 “Typescript”，但是使用起来和 Typescript 相差太多，而且无法完全直接使用 JavaScript 的第三方库，调试等也并不是很方便。</p><p>而剩余的几类语言中（Rust、C++、Kotin、Golang），相对来说 Rust 和 C++ 的 wasm 编译都较为成熟，Rust 更是在设计之初即考虑支持 WebAssembly 并且将其作为一个主要亮点，被 Rust 官方团队直接维护（包含了勤劳的 Alex Crichton，其也是 tokio 的作者）。因此我们使用 Rust 编译 WebAssembly 非常方便，并且可以直接使用大多数第三方 Rust 库，使用体验和 Rust Native 开发基本上没有差异。</p><p>目前笔者的项目中，有一部分模块即使用了 Rust + WebAssembly，同时支持了 Windows/Mac/iOS/Android/Web 五种平台，并且几乎都做到了最高性能。</p><blockquote><p>当然不得不承认，Rust 编译 WebAssembly 在使用到 C++ 的资源时也并不是十分方便，Rust 的 WASM 编译器和 Emscripten 也有诸多差异，适配起来会比较头疼，如果现有项目主要是 C++，还是建议直接使用 Emscripten。</p></blockquote><h2 id="重点语言特性"><a href="#重点语言特性" class="headerlink" title="重点语言特性"></a>重点语言特性</h2><p>Rust 拥有大多现代语言具备的特性，比如 RAII、动态数据类型等，另外还有不少设计是 Rust 中独有的，下面我们对一些 Rust 中比较独特的语言特性进行一些介绍。</p><h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>Rust 的所有权机制，即一个值同一个时刻只能被一个变量所引用，我们来看一个简单的例子：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;hello&quot;</span>.<span class="keyword">to</span><span class="constructor">_string()</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">println!(<span class="string">&quot;a: &#123;:?&#125;&quot;</span>, a); <span class="comment">// 提示报错：value borrowed here after move</span></span><br></pre></td></tr></table></figure><p>因为我们把 a 对应的数据的所有权给到了 b，也就是说 a 不再拥有对应的数据的所有权，因此也无法访问，<strong>这种机制保证了数据安全，能够有效避免悬垂指针的发生</strong>。</p><p>当然，对于实现了 Copy（一般来说，都是存储在栈上面的简单数据类型），在赋值阶段会自动拷贝，或者对于没有实现 Copy，但是实现了 Clone（需要主动调用）的类型我们显式调用 Clone，都可以编译通过，这些设计给我们的日常开发中带来了极大的便利：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">i32</span> = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;a: &#123;:?&#125;&quot;</span>, a); <span class="comment">// pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;hello&quot;</span>.to_string();</span><br><span class="line"><span class="keyword">let</span> b = a.clone();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;a: &#123;:?&#125;&quot;</span>, a); <span class="comment">// pass</span></span><br></pre></td></tr></table></figure><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>在 Rust 中，一般情况下并没有空指针的概念，并不像 c++ 有 nullptr、java 有 null，Rust 中如果表示一个可空的内容只能使用 Option（有点类似 C++ 的 std::optional）。</p><p>除了 Option，Rust 还封装了若干种高级指针，并对不同类型的指针的行为进行限制，以提高其安全性：</p><ul><li>Box：用于在堆上存储数据，<strong>单一所有权</strong>（即一般情况下不会存在一个指针乱飞的情况），可以用于封装在编译时未知大小的类型。</li><li>Rc：引用计数指针，不支持多线程</li><li>Arc：多线程版本的引用计数指针</li><li>RefCell：保持内部可变性的指针，即我们如果希望多个所有者共同拥有并且都可以修改的指针，需要结合 Rc 或 Arc 加 RefCell 一起使用。‘</li></ul><p>Rust 还提供了一些其他类型的智能指针，在这里不再过多介绍，虽然这里的大部分概念 c++ 也存在，但是 Rust 基本只能是强制你使用这些内容，而无法使用不安全的裸指针。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>Rust 中的多态有基于泛型的静态派发和基于 trait 的动态派发。</p><ul><li>静态派发：是一种零成本抽象，在 C++ 中也有类似的概念，静态派发是通过对不同类型的调用在编译期间生成不同版本的代码来实现的，不会引入运行时开销（但请注意可能会造成代码体积膨胀）。</li><li>动态派发：有些场景下，我们没有办法在编译期间确定变量的实际类型，进而无法确定其占用内存大小，Rust 也提供了 trait 机制来实现动态派发，同时 Rust 将此类 trait 使用 dyn 进行显式指定：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态派发：</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Speak</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Human</span></span>;</span><br><span class="line"><span class="keyword">impl</span> Speak <span class="keyword">for</span> Human &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hello, I am a Human&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_hello</span></span>(someone: <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Speak&gt;) &#123;</span><br><span class="line">    someone.hello();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> human = Human &#123;&#125;;</span><br><span class="line">    test_hello(<span class="built_in">Box</span>::new(human));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>Rust 中的宏的能力非常强大，其不同于 C/C++ 中的宏简单地按字符串替换代码，而是基于语法树进行操作，在编译阶段被展开成源代码进行嵌入。</p><p>具体 Rust 中的宏也分为声明宏和过程宏，能够实现的需求非常多样，在一个大型项目中，我们可以通过宏的使用解放生产力，并且使代码更清晰。不过，宏这一部分的具体学习相对比较复杂，在这里便不再进行举例。</p><hr><p>综合来说，Rust 作为一个比较先进的语言，没有太多的历史包袱，从各个语言中吸收了不少的优质特性，比较适合我们在新项目的技术选型中作为一个考虑因素。</p><h2 id="如何开始学习-rust"><a href="#如何开始学习-rust" class="headerlink" title="如何开始学习 rust"></a>如何开始学习 rust</h2><h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><p>rust 本身的文档和学习资料官方提供的比较全面，一个必读的内容是<a href="https://doc.rust-lang.org/book/">“The Rust Programming Language”</a>。</p><p>不过，rust 的官方文档读起来可能略有枯燥，这个时候我建议可以先开始读<em>张汉东</em>的《Rust 编程之道》，相对来说更加深入浅出，不过还是后续还是建议读一遍文档。</p><h3 id="项目应用"><a href="#项目应用" class="headerlink" title="项目应用"></a>项目应用</h3><p>在我们将上述内容读完之后（如果每天两个小时的话，大约需要一个月的时间），具备了一定的 Rust 语言基础，可能需要思考下如何在现有项目中落地，我个人的一个建议是：</p><ul><li>如果现有项目是偏 web 的，可以先考虑通过 wasm 来落地，相对来说上手成本很低，我之前也对<a href="https://zhuanlan.zhihu.com/p/104299612">入门 Rust 开发 WebAssembly</a>有所总结。</li><li>如果现有项目是偏 native 的，可以考虑将部分新模块、或者 crash 告警比较多的逻辑部分，使用 rust 实现并且通过 C FFI 和现有模块进行交互，渐进式引入 Rust 技术栈。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文希望从宏观角度，来介绍和分析 Rust 语言。&lt;/p&gt;
&lt;p&gt;Rust 是一门&lt;strong&gt;专注安全&lt;/strong&gt;的现代系统编程语言，发布于 2015 年。&lt;/p&gt;
&lt;p&gt;自从 2015 年发布起，Rust 就一直是 StackOverFlow 上面最受欢迎的语言</summary>
      
    
    
    
    
    <category term="Rust" scheme="https://z4ynadmin.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>一些性能相关的 JavaScript 代码编写建议规范</title>
    <link href="https://z4ynadmin.github.io/2021/08/29/%E4%B8%80%E4%BA%9B%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E7%9A%84%20JavaScript%20%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E5%BB%BA%E8%AE%AE%E8%A7%84%E8%8C%83/"/>
    <id>https://z4ynadmin.github.io/2021/08/29/%E4%B8%80%E4%BA%9B%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E7%9A%84%20JavaScript%20%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E5%BB%BA%E8%AE%AE%E8%A7%84%E8%8C%83/</id>
    <published>2021-08-29T05:59:00.000Z</published>
    <updated>2022-11-04T07:11:09.555Z</updated>
    
    <content type="html"><![CDATA[<p>本文对一些日常编写 JavaScript 的过程中，一些有助于提高代码性能的规范进行罗列。</p><blockquote><p>本文比较零碎，不作为规范提议，仅作为交流参考。</p></blockquote><h3 id="1-使用解构赋值，减少中间变量。"><a href="#1-使用解构赋值，减少中间变量。" class="headerlink" title="1. 使用解构赋值，减少中间变量。"></a>1. 使用解构赋值，减少中间变量。</h3><p>对于一些比如变量替换的场景，我们使用解构赋值，可以省略中间变量，整体代码也会更加清晰。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span> = <span class="number">4</span>;</span><br><span class="line">[b, a] = [a, b];</span><br></pre></td></tr></table></figure><h3 id="2-通过条件判断提前返回"><a href="#2-通过条件判断提前返回" class="headerlink" title="2. 通过条件判断提前返回"></a>2. 通过条件判断提前返回</h3><p>这里主要是提醒大家如何写好 if 语句。</p><p>实际上， 在编写复杂的 if 语句之前，我们应该考虑是否可以<strong>逻辑外化</strong>：</p><p>即尽可能的将代码的复杂逻辑向外推，例如抽离成多个函数，而不是在程序里面进行过多判断。有一种比较典型的不合理的重用是把大量的逻辑都堆叠到一个函数里面，然后提供一个很复杂的功能。我认为更好的做法应当是分离成更多的模块。</p><p>经过以上思考之后，我们可能还有一些 if 语句，一般的原则是：</p><ul><li>if 语句先简单，后复杂。</li><li>if 语句，可以提前返回即提前返回，减少复杂的嵌套。</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> nice:</span><br><span class="line"><span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">  <span class="regexp">//</span> <span class="keyword">do</span> something</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">  <span class="regexp">//</span> <span class="keyword">do</span> something</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">other_function();</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> bad:</span><br><span class="line"><span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">  <span class="regexp">//</span> <span class="keyword">do</span> something</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">    <span class="regexp">//</span> <span class="keyword">do</span> something</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    other_function();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-尽量避免在循环体内包裹函数表达式"><a href="#3-尽量避免在循环体内包裹函数表达式" class="headerlink" title="3. 尽量避免在循环体内包裹函数表达式"></a>3. 尽量避免在循环体内包裹函数表达式</h3><p>函数表达式会生成对应的函数对象，如果我们在循环体内去做这个事情，很可能会造成额外的浪费。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nice:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> len = nodelist.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">1</span>) &#123;</span><br><span class="line">  addListener(nodelist[i], callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad:</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nodelist.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">  addListener(nodelist[i], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-对循环体内的不变值，在循环体外使用缓存"><a href="#4-对循环体内的不变值，在循环体外使用缓存" class="headerlink" title="4. 对循环体内的不变值，在循环体外使用缓存"></a>4. 对循环体内的不变值，在循环体外使用缓存</h3><p>这一条其实是对上一条的补充，实际上是同样的原理，即希望我们在循环体内尽量保持逻辑的简单，减少重复的 cpu 时间和内存的消耗。</p><h3 id="5-清空数组使用-length-0"><a href="#5-清空数组使用-length-0" class="headerlink" title="5. 清空数组使用 .length = 0"></a>5. 清空数组使用 .length = 0</h3><p>这样写可以方便我们清空一个 const 数组。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="comment">// 如果使用 a = [] 会报错</span></span><br><span class="line">a.<span class="built_in">length</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="6-不得为了编写方便，将并行的-io-串行化"><a href="#6-不得为了编写方便，将并行的-io-串行化" class="headerlink" title="6. 不得为了编写方便，将并行的 io 串行化"></a>6. 不得为了编写方便，将并行的 io 串行化</h3><p>虽然现在 JavaScript 有了 async/await，但是我发现很多同学会对此滥用，一个很常见的清空就是将可以并行的操作串行化了:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">let</span> res<span class="number">1</span> = await process<span class="number">1</span>();</span><br><span class="line"><span class="attribute">let</span> res<span class="number">2</span> = await process<span class="number">2</span>();</span><br><span class="line"><span class="attribute">next</span>(res<span class="number">1</span>, res<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>这个时候，虽然写代码方便，但是这样写是不可取的，Promise 提供了若干的方便我们处理并行任务的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise#">方法</a>，我认为这些都是必须要了解的。</p><h3 id="7-禁止直接使用-eval"><a href="#7-禁止直接使用-eval" class="headerlink" title="7. 禁止直接使用 eval"></a>7. 禁止直接使用 eval</h3><p>eval 的安全性非常差，事实上有很多已知的 xss 等漏洞都和 eval 有关，所以我们在实际场景中避免使用 eval。</p><p>如下为一个例子，使用了 eval 函数，由于其执行代码的作用域为本地作用域，所以对我们的本地变量进行了修改并且可以生效：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">tip</span> = <span class="string">&quot;请重新登录&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">otherCode</span> = `<span class="attr">tip</span> = <span class="string">&quot;请前往 xxx.com 重新登录&quot;</span>`</span><br><span class="line">eval(otherCode);</span><br></pre></td></tr></table></figure><p>一些取代方式：</p><p>我们可以使用 <code>new Function</code> 的方式来代替 eval，这样至少可以进行作用域的隔离，相对会安全一些（但是请注意其仍然会可能影响到全局变量）。</p><h3 id="8-浏览器环境中，尽量避免使用-document-all、document-querySelectorAll"><a href="#8-浏览器环境中，尽量避免使用-document-all、document-querySelectorAll" class="headerlink" title="8. 浏览器环境中，尽量避免使用 document.all、document.querySelectorAll"></a>8. 浏览器环境中，尽量避免使用 document.all、document.querySelectorAll</h3><p>类似的 all 相关操作都要避免使用，由于我们很难控制随着项目发展内容会有多少，所以我们最好一开始就不要留下随着项目内容增加性能越来越差的隐患。</p><h3 id="9-获取元素的样式，尽量使用-getComputedStyle-或-currentStyle"><a href="#9-获取元素的样式，尽量使用-getComputedStyle-或-currentStyle" class="headerlink" title="9. 获取元素的样式，尽量使用 getComputedStyle 或 currentStyle"></a>9. 获取元素的样式，尽量使用 getComputedStyle 或 currentStyle</h3><p>通过 style 只能获得内联定义或通过 JavaScript 直接定义的样式，通过 CSS class 设置的样式无法直接获取。</p><h3 id="10-尽可能通过为元素添加预定义的-ClassName-来改变元素样式，避免直接操作-style-进行设置。"><a href="#10-尽可能通过为元素添加预定义的-ClassName-来改变元素样式，避免直接操作-style-进行设置。" class="headerlink" title="10. 尽可能通过为元素添加预定义的 ClassName 来改变元素样式，避免直接操作 style 进行设置。"></a>10. 尽可能通过为元素添加预定义的 ClassName 来改变元素样式，避免直接操作 style 进行设置。</h3><p>直接操作 style，会比较混乱，而且有的时候还会忘记写单位，导致实际上不管用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文对一些日常编写 JavaScript 的过程中，一些有助于提高代码性能的规范进行罗列。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文比较零碎，不作为规范提议，仅作为交流参考。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-使用解构赋值，减少中间变量。&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="javascript" scheme="https://z4ynadmin.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>如何让你的精力更多的用于提高技术深度</title>
    <link href="https://z4ynadmin.github.io/2021/07/26/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%B2%BE%E5%8A%9B%E6%9B%B4%E5%A4%9A%E7%9A%84%E7%94%A8%E4%BA%8E%E6%8F%90%E9%AB%98%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%BA%A6/"/>
    <id>https://z4ynadmin.github.io/2021/07/26/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%B2%BE%E5%8A%9B%E6%9B%B4%E5%A4%9A%E7%9A%84%E7%94%A8%E4%BA%8E%E6%8F%90%E9%AB%98%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%BA%A6/</id>
    <published>2021-07-26T15:42:20.000Z</published>
    <updated>2022-11-04T07:11:09.558Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/395177123">知乎版本</a></p><p>题目所述，就是我最近很久一段时间都在用来思考的问题。</p><p>先说下个人的背景，目前已经毕业三年，第一年主要做前端开发，大约在两年前，我的主要精力从前端转向了 Rust，而后又开始在公司参与开发 c++。</p><p>在这三年里面，自己持续面临着一个问题，这个问题就是，如何从一个繁忙而重复的工作中，持续提升自己的技术深度。</p><p>因为我发现，当在一个公司久了以后，随着参与的业务增多，问题和 OnCall 也随之增多，另外随着你对业务的熟悉，会有越来越多的新同学向你问问题。处理这些问题会占据越来越多的精力。当然，如果你比较“幸运”中途业务黄掉或架构彻底变化了，你去参与新的项目，有可能能获得一次接近重新开始的机会，但大多数时候，你可能都没有这么幸运。</p><p>当这些问题处理的久了以后，你会发现甚至连完成工作都需要加班来解决，就更没有时间来进行技术的提升了，长此以往，焦虑感便倍增。</p><p>不过，最近我在思考这些问题的过程中，也渐渐总结了一些缓解的办法，接下来便和大家进行分享。</p><p><strong>这里的核心点在于，减少犯错误的机会，提高处理问题的效率，释放出自己的更多时间</strong></p><h2 id="1-提高对代码的要求，写更好的代码"><a href="#1-提高对代码的要求，写更好的代码" class="headerlink" title="1. 提高对代码的要求，写更好的代码"></a>1. 提高对代码的要求，写更好的代码</h2><p>我最近处理的众多问题，粗略估算，有大约 1/3 都是由于开发者代码水平不足带来的技术债务（即代码逻辑错误、边界情况未考虑、性能与稳定性不足等）。</p><p>我这里主要针对的是 PC 客户端，还有很多问题和特殊机器、其他模块干扰项、硬件驱动等关系密切，如果是纯前端项目，这个比例只会更高。</p><p>因为写代码的时候，并没有采用最合理的方式，导致有出现问题的隐患，如果你的问题出现的概率比较高，大概率会比较幸运地较早发现，但如果出现的概率低，甚至灰度阶段都没有暴露，那么当初几行代码的问题，会让自己之后花加倍的时间来去处理，甚至还可能面临更多后果。</p><p>那么，如何让自己写出更好的代码呢，我认为可以做到以下几点：</p><ul><li><strong>请熟读文档</strong>，比如如果是在开发 Vue 项目，那么请至少把 Vue 的文档看一遍，React 同理，这样你会更加清楚，框架到底提供了那些能力，什么时候使用更合适的 API 来完成一个目标。</li><li>注重注释，对于一些特殊处理的情况，注释是很有必要的，最好附上文档，否则可能时间久了，自己都不知道为什么这样去处理，会让修复问题花费更多的时间。</li><li>除非迫不得已，不要提交带有已知优化项的代码，例如重复代码并没有完全处理、代码在某些情况还可能造成问题。时间允许的情况下，一步到位，通常比分两次到位能节约更多的时间，至少能节约一次测试的时间，另外大脑的上下文切换还有开销。</li><li>CI/CD 的建设，保证合并的代码是能够编译的。</li><li>对于前端来说，全部采用 Typescript，使用 ESLint 约束代码，<strong>禁止</strong>直接使用 JavaScript。</li><li>团队需要建立 Review 机制，并且对 Review 过程负责。对于别人提交 Review 的代码至少需要通读一遍，避免基本的错误。</li></ul><h2 id="2-日志是语言的另一面，也很能体现代码水平"><a href="#2-日志是语言的另一面，也很能体现代码水平" class="headerlink" title="2. 日志是语言的另一面，也很能体现代码水平"></a>2. 日志是语言的另一面，也很能体现代码水平</h2><p>这里的日志，指的是在用户使用过程中，实时上传的的或者离线的日志。</p><p>这里单独提一点日志，是因为在实际中，我们大约有一半时间在写代码，而另外一半时间在查问题，那么为什么就不能好好写日志呢？</p><p>“日志不足/没打日志，需要加日志进一步定位”。</p><p>不知道你在 OnCall 的过程中，是否遇到过此类回复，当然并不能说每次这样的问题都是开发者水平不足导致日志不全，但的确有很多情况是我们可以提前规避的。</p><p>那么一个好的日志应该是什么样的呢？</p><ol><li>前提：废话不要多，能简写就简写，这是因为一般日志都是存在用户本地的，日志量比较大的情况下会影响用户的硬盘占用，当然日志本身的打印也是消耗 CPU 的。</li><li>关键路径的日志要有，可能出问题的地方不要存在侥幸心理，把日志打全，特别是<strong>不同负责模块之间衔接的日志，一定打全</strong>，这样之后甩锅的时候有实锤也会方便一点。</li><li>关键日志需要有关键字，方便后面自动化分析，毕竟，对于一个比较完善的项目而言，机器人分析日志甚至比人分析更为靠谱。</li><li>日志也需要<strong>向前兼容</strong>，最好不要对以前的日志进行改动，这点我们可能通常会忽略，如果没有必要，建议不要对日志进行大的变动，防止自动化工具和其他分析日志的同学不知情。</li></ol><p>什么？你说你们团队还没有日志系统？</p><p>那么第一件事，就是要有一个完善的离线日志回捞系统或在线日志系统。</p><h2 id="3-打破边界有助于开阔视野，但是是否深入需要慎重决定"><a href="#3-打破边界有助于开阔视野，但是是否深入需要慎重决定" class="headerlink" title="3. 打破边界有助于开阔视野，但是是否深入需要慎重决定"></a>3. 打破边界有助于开阔视野，但是是否深入需要慎重决定</h2><p>虽然有的时候，员工打破边界对于公司来书并不是一个好事情，但大多数情况来说，对个人还是会有所帮助的。</p><blockquote><p>为什么说不是一个好事情呢，比如一个客户端的同学，去做 c++ 了，这个时候应该鼓励还是反对呢。实际上这个时候，他除了仅存的业务熟悉度和一些通用的编程能力，c++ 的能力也许就只有应届生的水平，如果从新招聘可能连初试都过不了。公司就必须要承担因为他的编程能力不熟练带来的效率损失，甚至因为更容易引发问题造成更大的损失。</p></blockquote><p>为什么说，对于个人来说是一个好事情呢，这个主要体现在以下几个方面：</p><ul><li>在公司中大多数情况下都是多个语言的开发者相互配合的，而当你同时参与了你上游或者下游的工作，你会发现沟通会更加顺畅了，甚至自己也拥有了简单的处理需求和问题的能力，底气会高很多。</li><li>在你学习多个语言的过程中你会发现一些精华的部分，比如通用的框架设计方法、模块组织方法等各个语言都是通用的，甚至有些代码你直接翻译过来就可以直接用了，这也可以让你更深刻地了解到哪些是编程的精髓。</li></ul><p>当然，有的时候如果你跨界参与的太多，例如本身是一个资深的前端开发者，当你跨界参与了 c++ 开发，你会发现短时间内你的前端水平是在下降的，而 c++ 水平也没有达到独立承担工作的程度，这短时间内你的市场价值其实是有所下降的，这也是你需要慎重考虑到底要参与多少的原因之一。</p><h2 id="4-复杂系统的初始架构设计，可以作为一个最后兜底"><a href="#4-复杂系统的初始架构设计，可以作为一个最后兜底" class="headerlink" title="4. 复杂系统的初始架构设计，可以作为一个最后兜底"></a>4. 复杂系统的初始架构设计，可以作为一个最后兜底</h2><p>实际上，复杂的系统大多一开始都不复杂，但是如何正确地预判系统的走向，设计出可以沿用很久的基础骨架、约束性强却扩展型足够的组件系统（即使后来来的人水平差也不至于写出太难维护的代码），以及和外界其他系统进行灵活的配合，是对水平有一定的考验的。</p><p>这里我以某视频会议 App 举例，其最开始只有视频+音频的简单能力，在此基础上，团队负责人设计并编写了基于 Typescript 的核心状态机、按照 minor repo 划分了主要模块，设计了 Store 状态存储，设计了一套 API 注入方式可以注入系统外的 API 等等。</p><p>这套架构沿用了三年，核心代码基本没有发生变化，功能上却新增了共享屏幕、共享网页、聊天/表情、标注/白板、远程控制、字幕/录制/翻译、日程会议、面试等若干重要的模块。</p><p>虽然实际上，随着后面的同学的增多，以及最初核心开发者的离职，开发人员已经几乎换了一批，但是这套代码和架构基本上没发生太多变化，也一直支撑着若干项目。</p><p>（p.s. 据说最开始参与设计的同学吐槽后面的维护有点渐渐跑题，但是整体还是可用性比较高的）。</p><p>如果没有一定水平，想必业务框架早就随着业务的变更重构过多次了，肯定会带来巨大的人力浪费。</p><h2 id="5-持续练习，持续关注行业动态"><a href="#5-持续练习，持续关注行业动态" class="headerlink" title="5. 持续练习，持续关注行业动态"></a>5. 持续练习，持续关注行业动态</h2><p>最后一点，持续学习，大概是程序员的宿命吧。</p><p>这里其实不用多说了，但是想提一点，其实有的时候如果你发现主动的持续学习会比较难的情况下，可以选择一种半被动的方式。</p><p>比如，每周给自己定日程参与 leetcode 周赛，你把它当作自己工作的无可推脱的一部分，这样持续几次，你就会慢慢习惯这个过程。</p><hr><p>以上共勉。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/395177123&quot;&gt;知乎版本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目所述，就是我最近很久一段时间都在用来思考的问题。&lt;/p&gt;
&lt;p&gt;先说下个人的背景，目前已经毕业三年，第一年主要做前端开发，大约在两年前，我的</summary>
      
    
    
    
    
    <category term="前端综合" scheme="https://z4ynadmin.github.io/tags/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Deno 是如何运行 TypeScript 的？</title>
    <link href="https://z4ynadmin.github.io/2021/01/31/Deno%20%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%20TypeScript%20%E7%9A%84/"/>
    <id>https://z4ynadmin.github.io/2021/01/31/Deno%20%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%20TypeScript%20%E7%9A%84/</id>
    <published>2021-01-31T10:07:20.000Z</published>
    <updated>2022-11-04T07:11:09.550Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Deno，一个 JavaScript/TypeScript 运行时。本文并不会从 JavaScript 的角度来去介绍如何使用 Deno，而是试图从框架实现的角度，来整体对 Deno 项目本身的开发实现进行解读，并且通过分析其运行 TypeScript 的原理，来对其进行一个入门的剖析。</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/348379605">原文链接已经转移至这里</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Deno，一个 JavaScript/TypeScript 运行时。本文并不会从 JavaScript 的角度来去介绍如何使用 Deno，而是试图从框架实现的角度，来整体对 Deno 项目本身的开发实现进行解读，并且通过分析其运行 TypeScri</summary>
      
    
    
    
    
    <category term="前端框架" scheme="https://z4ynadmin.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>使用 Rust WebAssembly 0拷贝进行计算加速</title>
    <link href="https://z4ynadmin.github.io/2020/06/26/%E4%BD%BF%E7%94%A8RustWebAssembly0%E6%8B%B7%E8%B4%9D%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97%E5%8A%A0%E9%80%9F/"/>
    <id>https://z4ynadmin.github.io/2020/06/26/%E4%BD%BF%E7%94%A8RustWebAssembly0%E6%8B%B7%E8%B4%9D%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97%E5%8A%A0%E9%80%9F/</id>
    <published>2020-06-26T06:47:03.000Z</published>
    <updated>2022-11-04T07:11:09.556Z</updated>
    
    <content type="html"><![CDATA[<p>demo: <a href="https://github.com/aircloud/rust-wasm-demo">https://github.com/aircloud/rust-wasm-demo</a>  </p><p>其他资料：<a href="https://zhuanlan.zhihu.com/p/104299612">入门 Rust 开发 WebAssembly</a></p><p>一般来说，使用 WebAssembly 能够在一定程度上提高性能，不过有的时候我们也许会发现，使用 WebAssembly 之后，有的时候我们不仅发现性能没有提升，反而下降了许多甚至数倍，实际上这是因为，使用 WebAssembly 需要非常谨慎，有很多细节都会大幅度影响性能，比如：</p><ul><li>我们编译采用的是 debug 还是 release 方式。</li><li>最后编译的结果是否采用了不同级别的优化，如果使用了 <code>opt-level = &#39;s&#39;</code> 那么通常速度也会下降很多。</li><li>是否在 JS 和 rust 之间存在大量的数据拷贝，因为很多代码是工具链生成的，也许有的时候我们会忽视这一点。</li></ul><p>本文针对以上等一些问题特别是第三点，给出一个 wasm 优化的参考方案，并给出示例代码。</p><h3 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h3><p>我们在优化数据拷贝之前，对于编译我们可以做一些前置的简单的工作。</p><ul><li>检查 Cargo.toml 脚本中 <code>[profile.release]</code> 中的 <code>opt-level</code> 选项，确认我们所使用的值：</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">This flag controls the optimization <span class="keyword">level</span>.</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>: <span class="keyword">no</span> optimizations, <span class="keyword">also</span> turns <span class="keyword">on</span> cfg(debug_assertions) (the <span class="keyword">default</span>).</span><br><span class="line"><span class="number">1</span>: basic optimizations.</span><br><span class="line"><span class="number">2</span>: <span class="keyword">some</span> optimizations.</span><br><span class="line"><span class="number">3</span>: <span class="keyword">all</span> optimizations.</span><br><span class="line">s: optimize <span class="keyword">for</span> binary size.</span><br><span class="line">z: optimize <span class="keyword">for</span> binary size, but <span class="keyword">also</span> turn <span class="keyword">off</span> <span class="keyword">loop</span> vectorization.</span><br><span class="line">Note: The -O flag <span class="keyword">is</span> an <span class="keyword">alias</span> <span class="keyword">for</span> -C opt-<span class="keyword">level</span>=<span class="number">2.</span></span><br><span class="line"></span><br><span class="line">The <span class="keyword">default</span> <span class="keyword">is</span> <span class="number">0.</span></span><br></pre></td></tr></table></figure><p>如果我们使用了 ‘s’ 或者 ‘z’，那么通常会牺牲一部分性能（对于 demo 而言，使用 ‘z’， wasm 的性能也只有 js 的 20%），因为其主要是对体积进行一定的优化，所以如果优化前的体积我们可以接受的话，通常不需要这样的优化。</p><p>在以上的前提下，我们使用 <code>--release</code> 的方式编译，通常就可以了。</p><h3 id="减少拷贝"><a href="#减少拷贝" class="headerlink" title="减少拷贝"></a>减少拷贝</h3><p>在这之前，我们需要有一个认知：</p><p><strong>通过 rust 工具链编译的 wasm 代码，所有参数传入都是需要拷贝一次的，包括我们传入 ArrayBuffer 等 Buffer 类型的参数。</strong>这是由于 wasm 只能访问自己的线性内存，而这个拷贝，通常是我们在处理大规模计算的一个坎，有的时候虽然 wasm 计算快一点，但是拷贝的消耗还是比较大的，加之 js 有若干 v8 优化的加持，可能和 wasm 也相差不多。</p><p>所以我们要把计算移植到 wasm 中的话，首先要解决的就是大规模数据拷贝的问题。</p><p>这里的一般思路为：</p><ol><li>wasm 分配内存：调用 wasm 的方法，在 wasm 内存中分配空间，返回指针位置</li><li>js 写入数据：js 端在 wasm 的 memory arraybuffer 上，按指针位置和数据量建立 view，把数据写入</li><li>wasm 计算：调用 wasm 方法完成计算， 返回计算好的批量结果的指针位置和大小</li><li>js 读取数据：js 端在 wasm 的 memory arraybuffer上，按指针位置和数据量建立 view，把数据读出</li></ol><p>接下来，我们通过一个 demo 来完成以上几点，demo 的主要功能为：</p><ul><li>初始化一个 ImageData，内容随机。</li><li>分别使用 js 和 WebAssembly 进行高斯模糊计算，并计算二者的时间，进行对比。</li></ul><p>这里的 demo 只是辅助进行验证改方案的可行性并且给出一个示例，并不作为一个标准的 benchmark 去对比 js 和 WebAssembly 的性能，同时，也并没有 UI 展示，计算结果输出在控制台中。</p><p>最终笔者运行的结果为，js 比 WebAssembly 慢 30% 左右。</p><h4 id="1-wasm-分配内存"><a href="#1-wasm-分配内存" class="headerlink" title="1. wasm 分配内存"></a>1. wasm 分配内存</h4><p>这部分的通用做法，即我们在 wasm 的 rust 中分配一个数组（Vec），然后把其指针传递给 js：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rust：</span></span><br><span class="line"><span class="meta">#[wasm_bindgen]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new_buffer</span></span>(key: <span class="built_in">String</span>, len: <span class="built_in">usize</span>) -&gt; *<span class="keyword">const</span> <span class="built_in">u8</span> &#123;</span><br><span class="line">  <span class="comment">// GlobalBufferStorage 是一个 lazy_static</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> global_buffer_storage = GlobalBufferStorage.lock().unwrap();</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> buffer = <span class="built_in">vec!</span>[<span class="number">255</span>; len];</span><br><span class="line">  <span class="keyword">let</span> ptr = buffer.as_ptr();</span><br><span class="line">  global_buffer_storage.buffer_map.insert(key, buffer);</span><br><span class="line">  ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了后续方便寻找到这段数据，我们可以使用一个 key 将这个 Vec 联系起来，并且在 Rust 中放入全局（可以使用 lazy_static!，因为这种类型的数据没有办法直接定义在全局），之后通过 key 来查找数据。</p><p>在 js 中，我们就可以建立各种 TypedArray 对其进行操作：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const ptr = this.wasm!.<span class="keyword">new</span><span class="constructor">_buffer(<span class="params">key</span>, <span class="params">len</span>)</span>;</span><br><span class="line">const u8Arr = <span class="keyword">new</span> <span class="constructor">Uint8ClampedArray(<span class="params">this</span>.<span class="params">wasm</span>!.<span class="params">get_wasm_buffer</span>()</span>, ptr, len);</span><br></pre></td></tr></table></figure><p><strong>这个时候，我们在 js 或 rust 任何一侧改了这个数据之后，都可以在另外一侧访问到。</strong></p><p>实际上，在 js 侧的比如 <a href="https://developer.mozilla.org/en-US/docs/Web/API/ImageData/ImageData">ImageData</a> 等一些对象中，也支持我们传递一个 TypedArray 进行初始化，这让我们在比如 canvas 等应用场景下，使用 wasm 分配的内存更为方便。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const imageData = <span class="keyword">new</span> <span class="constructor">ImageData(<span class="params">u8Arr</span>, <span class="params">width</span>, <span class="params">height</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="2-js-写入数据"><a href="#2-js-写入数据" class="headerlink" title="2. js 写入数据"></a>2. js 写入数据</h4><p>如果我们需要在 js 侧写入数据，实际上这个时候我们得到的 TypedArray 已经和直接使用 js new 的 TypedArray 在使用上没有差别，可以正常按照数组的方式进行数据写入。</p><p>不过，这里需要注意的是，js 写入通过 wasm 分配内存建立的 TypedArray，有些场景下在一定程度上速度要慢于直接使用 js new 的 TypedArray（不过在笔者的测试数据中，wasm 分配的方式反而是更快的），所以如果我们是一个高频的数据写入的场景，比如帧数据等，这个时候最好进行一次对比测试。</p><h4 id="3-wasm-计算"><a href="#3-wasm-计算" class="headerlink" title="3. wasm 计算"></a>3. wasm 计算</h4><p>当我们真正需要进行计算的时候，我们可以调用 wasm 的计算函数，并且传入上文中定义的 key，这样 wasm 的 rust 函数可以直接找到这段数据，这里我们的 demo 为一段计算卷积的函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[wasm_bindgen]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">convolution</span></span>(key: <span class="built_in">String</span>, width: <span class="built_in">usize</span>, height: <span class="built_in">usize</span>, kernel: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> global_buffer_storage = GlobalBufferStorage.lock().unwrap();</span><br><span class="line">  <span class="keyword">let</span> kernel_length = kernel.iter().sum::&lt;<span class="built_in">i32</span>&gt;() <span class="keyword">as</span> <span class="built_in">i32</span>;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(buffer) = global_buffer_storage.buffer_map.get_mut(&amp;key) &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..width-<span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>..height-<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> newR: <span class="built_in">i32</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> newG: <span class="built_in">i32</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> newB: <span class="built_in">i32</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123; <span class="comment">// 取前后左右共9个格子</span></span><br><span class="line">          <span class="keyword">for</span> y <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">            newR += buffer[width * (j + y - <span class="number">1</span>) * <span class="number">4</span> + (i + x - <span class="number">1</span>) * <span class="number">4</span> + <span class="number">0</span>] <span class="keyword">as</span> <span class="built_in">i32</span> * kernel[y * <span class="number">3</span> + x] / kernel_length;</span><br><span class="line">            newG += buffer[width * (j + y - <span class="number">1</span>) * <span class="number">4</span> + (i + x - <span class="number">1</span>) * <span class="number">4</span> + <span class="number">1</span>] <span class="keyword">as</span> <span class="built_in">i32</span> * kernel[y * <span class="number">3</span> + x] / kernel_length;</span><br><span class="line">            newB += buffer[width * (j + y - <span class="number">1</span>) * <span class="number">4</span> + (i + x - <span class="number">1</span>) * <span class="number">4</span> + <span class="number">2</span>] <span class="keyword">as</span> <span class="built_in">i32</span> * kernel[y * <span class="number">3</span> + x] / kernel_length;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer[width * j * <span class="number">4</span> + i * <span class="number">4</span> + <span class="number">0</span>] = newR <span class="keyword">as</span> <span class="built_in">u8</span>;</span><br><span class="line">        buffer[width * j * <span class="number">4</span> + i * <span class="number">4</span> + <span class="number">1</span>] = newG <span class="keyword">as</span> <span class="built_in">u8</span>;</span><br><span class="line">        buffer[width * j * <span class="number">4</span> + i * <span class="number">4</span> + <span class="number">2</span>] = newB <span class="keyword">as</span> <span class="built_in">u8</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这段函数对应操作的内存数据实际上已经在 wasm 和 js 之间共享了，所以也是不需要返回值的，等计算完成后 js 直接去读之前建立的 TypedArray，甚至直接使用通过 TypedArray 创建的 ImageData，进行绘制上屏等后续操作。</p><h4 id="4-js-读取数据"><a href="#4-js-读取数据" class="headerlink" title="4. js 读取数据"></a>4. js 读取数据</h4><p>在 demo 中，我们可以直接通过 <code>CanvasRenderingContext2D.putImageData()</code> 传入之前获取的 imageData，绘制上屏。</p><h3 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h3><p>实际上，我们如果目的是加速 js 计算，不仅仅有 WebAssembly 这一个方案可以选择，如果我们的环境中拥有可以访问 Node 的能力或者可以访问原生模块的能力（比如，我们的应用运行在 electron 环境，或者是一些移动客户端），也可以采用比如 addon 的方式来运行我们的计算部分，相比于 wasm，这部分的优缺点在于：</p><p>优点：</p><ul><li>通常可以更好的控制优化，甚至做到汇编级别的优化定制，性能提升空间更高（同样也可能会面临数据拷贝的问题，也需要一定方式减少拷贝）。</li><li>在重 addon 的环境下（例如，其他大量功能也依赖 addon），可以更好的处理函数调用关系、依赖库使用等，一定程度上减少体积和增加开发的便捷性，而 wasm 会被编译成一个独立的二进制文件，处于沙盒环境中，无法直接调用其他的动态库。</li></ul><p>缺点：</p><ul><li>无法做到像 wasm 一样跨平台，并且可以同时运行在网页、桌面环境、移动端等任何 Webview 存在的环境中。</li></ul><p>不过总之，如果使用得当，二者的性能都是可以优于原生的 js，都可以作为优化方案考虑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;demo: &lt;a href=&quot;https://github.com/aircloud/rust-wasm-demo&quot;&gt;https://github.com/aircloud/rust-wasm-demo&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;其他资料：&lt;a href=&quot;https://</summary>
      
    
    
    
    
    <category term="Rust" scheme="https://z4ynadmin.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>使用 OpenCV 实现简单的人脸识别程序</title>
    <link href="https://z4ynadmin.github.io/2019/09/10/%E4%BD%BF%E7%94%A8OpenCV%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%A8%8B%E5%BA%8F/"/>
    <id>https://z4ynadmin.github.io/2019/09/10/%E4%BD%BF%E7%94%A8OpenCV%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%A8%8B%E5%BA%8F/</id>
    <published>2019-09-10T07:34:13.000Z</published>
    <updated>2022-11-04T07:11:09.556Z</updated>
    
    <content type="html"><![CDATA[<p>本问就 Mac 系统安装 OpenCV 以及实现一个简单的人脸识别程序进行记录。</p><h3 id="安装-OpenCV"><a href="#安装-OpenCV" class="headerlink" title="安装 OpenCV"></a>安装 OpenCV</h3><p>实际上，OpenCV 的安装方式比较多，这里为了避免一些第三方安装的问题，我们采用源代码方式安装。</p><p>安全前请确保本机已经安装了 CMake 和 Xcode。</p><p>我们去<a href="https://opencv.org/releases/"> OpenCV 的网站</a> 下载源代码，选择 Release -&gt; SourceCode，可以选择最新的 4.11 版本。</p><p>这里以 4.1.1 版本为例，下载后我们解压到 <code>opencv-4.1.1</code>，然后进入到该目录，新建一个 release 目录用于存放我们构建好的内容，并进入到该目录：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir release</span><br><span class="line">cd release/</span><br></pre></td></tr></table></figure><p>然后我们依次执行以下命令安装：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake -G “Unix Makefiles” .. </span><br><span class="line"><span class="built_in">make</span></span><br><span class="line"><span class="built_in">make</span> install</span><br></pre></td></tr></table></figure><p>全部命令执行成功后，实际上就安装完成了，我们可以从最后的输出中看到，相关内容已经被安装到了 <code>/usr/local/include</code>、<code>/usr/local/lib</code> 等文件夹下。</p><h3 id="使用-Xcode-编写人脸识别程序"><a href="#使用-Xcode-编写人脸识别程序" class="headerlink" title="使用 Xcode 编写人脸识别程序"></a>使用 Xcode 编写人脸识别程序</h3><p>我们可以使用 Xcode 建立一个命令行程序，这里我们还需要处理两个问题：</p><ul><li>OpenCV 的引入</li><li>摄像头权限的获取</li></ul><h4 id="OpenCV-的引入"><a href="#OpenCV-的引入" class="headerlink" title="OpenCV 的引入"></a>OpenCV 的引入</h4><p>对于第一点，我们在 <strong>Build Setting</strong> 的 <strong>Search Paths</strong> 中增加 Header 和 Library 的路径：</p><p><img src="/img/cv1.jpg" alt="路径"></p><p>然后我们需要在 <strong>Build Phases</strong> 的 <strong>Link Binary With Libraries</strong> 中增加动态链接库。</p><p>我们可以点击左下角加号，选择 <code>Add Others</code> 然后进入 <code>/usr/local/lib</code> 把 OpenCV 相关的库均包含进来即可。</p><blockquote><p>实际上我们可以部分引入，但是由于我们是初步上手，全部引入也可以。</p></blockquote><h4 id="摄像头权限的获取"><a href="#摄像头权限的获取" class="headerlink" title="摄像头权限的获取"></a>摄像头权限的获取</h4><p>这里如果我们直接运行我们的程序，在 macOS 最新的系统中是无法运行通过的，这里涉及到摄像头权限问题。</p><p>一般来说，对于 macOS，我们需要在运行程序的目录下声明 <code>info.plist</code>, 这样程序在运行的时候系统会自动有申请权限的弹窗，对于我们测试场景下而言，我们可以这样做：</p><ul><li>进入我们 Product 存放的目录（注意不是项目代码目录，可以在 Products 条目右单击 <code>Show in Finder</code>）</li><li>复制一个 info.plist（这里我们可以随便找一个本地安装的应用程序的 info.plist，一般右单击显示包内容即可看到）</li><li>在 info.plist 中增加 <code>NSCameraUsageDescription</code>，value 即提示语，可以写比如 <code>摄像头权限的获取</code>。</li></ul><h4 id="书写并运行程序"><a href="#书写并运行程序" class="headerlink" title="书写并运行程序"></a>书写并运行程序</h4><p>做完上述准备工作后，我们可以写我们的人脸识别程序了，这里给出一个成功运行的代码示例（参考了网上的一些例子）：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">capture</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否退出摄像头抓取线程</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> g_quit = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">capture</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">capture</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打开摄像头</span></span><br><span class="line">    <span class="function">cv::VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果打开失败，返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (!cap.<span class="built_in">isOpened</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Open Capture Failed&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 人脸识别分类器</span></span><br><span class="line">    <span class="function">cv::CascadeClassifier <span class="title">faceCascadeClassifier</span><span class="params">(<span class="string">&quot;/usr/local/share/opencv4/haarcascades/haarcascade_frontalface_alt2.xml&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取 Frame ，直到退出系统</span></span><br><span class="line">    <span class="keyword">while</span> (!g_quit)</span><br><span class="line">    &#123;</span><br><span class="line">        cv::Mat frame;</span><br><span class="line">        <span class="keyword">if</span> (!cap.<span class="built_in">read</span>(frame))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 读取失败，返回错误</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进行人脸识别</span></span><br><span class="line">        std::vector&lt;cv::Rect&gt; faces;</span><br><span class="line">        faceCascadeClassifier.<span class="built_in">detectMultiScale</span>(frame, faces);</span><br><span class="line">        <span class="comment">// 将人脸识别结果绘制到图片上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; face : faces)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Find Face&quot;</span>&lt;&lt;endl;</span><br><span class="line">            cv::<span class="built_in">rectangle</span>(frame,</span><br><span class="line">                          cv::<span class="built_in">Point</span>(face.x, face.y),</span><br><span class="line">                          cv::<span class="built_in">Point</span>(face.x + face.width, face.y + face.height),</span><br><span class="line">                          <span class="built_in">CV_RGB</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">                          <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Display Image&quot;</span>, frame);</span><br><span class="line">        <span class="built_in">waitKey</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里值得注意的是，我们这里使用的人脸识别分类器是 OpenCV 安装后自带的，你本机的目录可能并不是这一个（这个路径实际上安装好 OpenCV 之后会打印在控制台）。</p><p>正常情况下，以上程序可以直接编译执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本问就 Mac 系统安装 OpenCV 以及实现一个简单的人脸识别程序进行记录。&lt;/p&gt;
&lt;h3 id=&quot;安装-OpenCV&quot;&gt;&lt;a href=&quot;#安装-OpenCV&quot; class=&quot;headerlink&quot; title=&quot;安装 OpenCV&quot;&gt;&lt;/a&gt;安装 OpenCV&lt;/</summary>
      
    
    
    
    
    <category term="OpenCV" scheme="https://z4ynadmin.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>Rust初探:实现二叉树的增删与遍历</title>
    <link href="https://z4ynadmin.github.io/2019/09/07/Rust%E5%88%9D%E6%8E%A2-%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A2%9E%E5%88%A0%E4%B8%8E%E9%81%8D%E5%8E%86/"/>
    <id>https://z4ynadmin.github.io/2019/09/07/Rust%E5%88%9D%E6%8E%A2-%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A2%9E%E5%88%A0%E4%B8%8E%E9%81%8D%E5%8E%86/</id>
    <published>2019-09-07T15:57:28.000Z</published>
    <updated>2022-11-04T07:11:09.552Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Rust-简介"><a href="#Rust-简介" class="headerlink" title="Rust 简介"></a>Rust 简介</h3><p>实际上自己接触 Rust 的时间还是很有限的，这里也不会对 Rust 进行长篇大论地介绍，简单来说，Rust 是一个性能和 c++ 相近的系统级编程语言，同时，由于其所有权与变量生命周期等机制的设计，使其相对于 c++ 来说拥有内存安全的优势，几乎不会出现诸如悬垂指针、数组越界、段错误等问题，在微软、百度、字节跳动等公司均有所使用。</p><p>关于 Rust 的特性以及未来，知乎<a href="https://www.zhihu.com/question/30407715">这个问题中的一些高赞回答以及相关的评论</a>，非常值得一看。</p><p>本文会以二叉树这样一个具体的例子出发，来对 Rust 的一部分知识内容进行学习。</p><h3 id="实现二叉树数据结构"><a href="#实现二叉树数据结构" class="headerlink" title="实现二叉树数据结构"></a>实现二叉树数据结构</h3><h4 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h4><p>之前在 Javascript 等语言中，我们只要对对象有所了解，实现一个二叉树的数据结构是非常简单的事情，而在 Rust 中，可能对于新手来说仅仅是实现基本的数据结构就是一个比较脑壳疼的事情。</p><p>我们一般会写出类似这样的代码：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="class">Tree </span>&#123;</span><br><span class="line"><span class="symbol">    value:</span> i32,</span><br><span class="line"><span class="symbol">    left:</span> Tree, <span class="comment">// 直接使用 Tree 是不行的</span></span><br><span class="line"><span class="symbol">    right:</span> Tree  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自然不会通过 Rust 的编译检查，会报错例如：<code>recursive type has infinite size</code>，不过其同时给我们提供了解决方案，这里我们使用 <code>Box&lt;T&gt;</code> 指针。</p><p>另外，考虑到二叉树的左右子树可能为空，所以这里我们还需要增加一个 <code>Option</code>。</p><p>最终我们的二叉树数据结构定义如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Default)]</span></span><br><span class="line">struct <span class="class">Tree </span>&#123;</span><br><span class="line"><span class="symbol">    value:</span> i32,</span><br><span class="line"><span class="symbol">    left:</span> Option<span class="params">&lt;Box&lt;Tree&gt;</span>&gt;,</span><br><span class="line"><span class="symbol">    right:</span> Option<span class="params">&lt;Box&lt;Tree&gt;</span>&gt;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现基本的方法"><a href="#实现基本的方法" class="headerlink" title="实现基本的方法"></a>实现基本的方法</h4><p>这里我们实现一些二叉树的基本的方法，作为上述结构体的方法，我们将实现以下方法：</p><ul><li>获取二叉树节点的值（其实也可以没有这个方法）。</li><li>修改二叉树节点的值。</li><li>设置子树。</li><li>删除子树。</li></ul><p>这里除了第一个，其余我们都需要传递 <code>self</code> 的可变引用，我们的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Tree &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_val</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">set_val</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, val: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = val;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">insert</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, dir: &amp;<span class="built_in">String</span>, val: Tree) &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(dir == <span class="string">&quot;left&quot;</span> || dir == <span class="string">&quot;right&quot;</span>);</span><br><span class="line">        <span class="keyword">match</span> dir.as_ref() &#123;</span><br><span class="line">            <span class="string">&quot;left&quot;</span> =&gt; <span class="keyword">self</span>.left = <span class="literal">Some</span>(<span class="built_in">Box</span>::new(val)),</span><br><span class="line">            <span class="string">&quot;right&quot;</span> =&gt; <span class="keyword">self</span>.right = <span class="literal">Some</span>(<span class="built_in">Box</span>::new(val)),</span><br><span class="line">            _ =&gt; &#123; </span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Insert Error: only left and right supported&quot;</span>);</span><br><span class="line">                process::exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">delete</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, dir: &amp;<span class="built_in">String</span>) &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(dir == <span class="string">&quot;left&quot;</span> || dir == <span class="string">&quot;right&quot;</span>);</span><br><span class="line">        <span class="keyword">match</span> dir.as_ref() &#123;</span><br><span class="line">                <span class="string">&quot;left&quot;</span> =&gt; <span class="keyword">self</span>.left = <span class="literal">None</span>,</span><br><span class="line">                <span class="string">&quot;right&quot;</span> =&gt; <span class="keyword">self</span>.right = <span class="literal">None</span>,</span><br><span class="line">                 _ =&gt; &#123; </span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;Insert Error: only left and right supported&quot;</span>);</span><br><span class="line">                    process::exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><p>这里遍历二叉树我们作为一个单独的方法，而不是属性方法来实现，这样会更符合我们平时的业务场景，这里其实问题比较多的，我们先简易实现一个版本：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">fn</span> <span class="selector-tag">traverse</span>(<span class="attribute">tree</span>: Tree) &#123;</span><br><span class="line">    <span class="selector-tag">println</span>!(<span class="string">&quot;Node Value: &#123;:?&#125;&quot;</span>, tree.value);</span><br><span class="line">    <span class="selector-tag">if</span> <span class="selector-tag">tree</span><span class="selector-class">.left</span><span class="selector-class">.is_some</span>() &#123;</span><br><span class="line">        <span class="selector-tag">traverse</span>(*tree.left.unwrap()); <span class="comment">// 手动解引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">if</span> <span class="selector-tag">tree</span><span class="selector-class">.right</span><span class="selector-class">.is_some</span>() &#123;</span><br><span class="line">        <span class="selector-tag">traverse</span>(*tree.right.unwrap()); <span class="comment">// 手动解引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们测试一下这个版本，发现的确能够正常遍历的，但是实际上这有一个致命的问题：</p><p>这里采用的是所有权的移动，而不是不可变借用，这会导致我们的函数执行完后原来变量的所有权已经被移动了，换一种说法则是会消耗掉这个变量，这显然不是我们预期的。</p><p>虽然我们也可以在函数中返回 tree 的方式来最后再次移动所有权，但这样非常不便于实现，经过重构，我们采用了如下的方式实现：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn traverse(tree: &amp;Tree) &#123;</span><br><span class="line">    println!(<span class="string">&quot;Node Value: &#123;:?&#125;&quot;</span>, tree.value);</span><br><span class="line">    <span class="keyword">match</span> tree.left &#123;</span><br><span class="line">        <span class="constructor">Some(<span class="params">ref</span> <span class="params">x</span>)</span> =&gt; traverse(x),</span><br><span class="line">       <span class="function"> <span class="params">_</span> =&gt;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">match</span> tree.right &#123;</span><br><span class="line">        <span class="constructor">Some(<span class="params">ref</span> <span class="params">x</span>)</span> =&gt; traverse(x),</span><br><span class="line">       <span class="function"> <span class="params">_</span> =&gt;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>另外一个注意点则是由于 <code>unwrap()</code> 本身是一个消耗性操作，我们这里不能使用 <code>unwrap</code>，参考<a href="https://stackoverflow.com/questions/22282117/how-do-i-borrow-a-reference-to-what-is-inside-an-optiont">stackOverflow的提问1</a>、<a href="https://stackoverflow.com/questions/32338659/cannot-move-out-of-borrowed-content-when-unwrapping">stackOverflow的提问2</a>。</p></blockquote><p>我们最终的完整代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">use::std::process;</span><br><span class="line"><span class="keyword">use</span> std::borrow::Borrow;</span><br><span class="line"><span class="meta">#[derive(Debug, Default)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span></span> &#123;</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">    left: <span class="built_in">Option</span>&lt;<span class="built_in">Box</span>&lt;Tree&gt;&gt;,</span><br><span class="line">    right: <span class="built_in">Option</span>&lt;<span class="built_in">Box</span>&lt;Tree&gt;&gt;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Tree &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_val</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">set_val</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, val: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = val;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">insert</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, dir: &amp;<span class="built_in">String</span>, val: Tree) &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(dir == <span class="string">&quot;left&quot;</span> || dir == <span class="string">&quot;right&quot;</span>);</span><br><span class="line">        <span class="keyword">match</span> dir.as_ref() &#123;</span><br><span class="line">            <span class="string">&quot;left&quot;</span> =&gt; <span class="keyword">self</span>.left = <span class="literal">Some</span>(<span class="built_in">Box</span>::new(val)),</span><br><span class="line">            <span class="string">&quot;right&quot;</span> =&gt; <span class="keyword">self</span>.right = <span class="literal">Some</span>(<span class="built_in">Box</span>::new(val)),</span><br><span class="line">            _ =&gt; &#123; </span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Insert Error: only left and right supported&quot;</span>);</span><br><span class="line">                process::exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">delete</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, dir: &amp;<span class="built_in">String</span>) &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(dir == <span class="string">&quot;left&quot;</span> || dir == <span class="string">&quot;right&quot;</span>);</span><br><span class="line">        <span class="keyword">match</span> dir.as_ref() &#123;</span><br><span class="line">                <span class="string">&quot;left&quot;</span> =&gt; <span class="keyword">self</span>.left = <span class="literal">None</span>,</span><br><span class="line">                <span class="string">&quot;right&quot;</span> =&gt; <span class="keyword">self</span>.right = <span class="literal">None</span>,</span><br><span class="line">                 _ =&gt; &#123; </span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;Insert Error: only left and right supported&quot;</span>);</span><br><span class="line">                    process::exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始的非消耗性遍历:</span></span><br><span class="line"><span class="comment">// fn traverse(tree: &amp;Tree) &#123;</span></span><br><span class="line"><span class="comment">//     println!(&quot;Node Value: &#123;:?&#125;&quot;, tree.value);</span></span><br><span class="line"><span class="comment">//     if tree.left.is_some() &#123;</span></span><br><span class="line"><span class="comment">//         // cannot move out of borrowed content</span></span><br><span class="line"><span class="comment">//         // 首先 unwrap 是一个消耗性操作</span></span><br><span class="line"><span class="comment">//         // 这是由于 unwrap 函数造成?  as_ref 也不行</span></span><br><span class="line"><span class="comment">//         traverse((tree.left.as_ref().map(|x| **x).unwrap()).borrow());</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     // if tree.right.is_some() &#123;</span></span><br><span class="line"><span class="comment">//     //     // cannot move out of borrowed content</span></span><br><span class="line"><span class="comment">//     //     traverse(tree.right.unwrap().borrow());</span></span><br><span class="line"><span class="comment">//     // &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非消耗性遍历</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">traverse</span></span>(tree: &amp;Tree) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Node Value: &#123;:?&#125;&quot;</span>, tree.value);</span><br><span class="line">    <span class="keyword">match</span> tree.left &#123;</span><br><span class="line">        <span class="literal">Some</span>(<span class="keyword">ref</span> x) =&gt; traverse(x),</span><br><span class="line">        _ =&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">match</span> tree.right &#123;</span><br><span class="line">        <span class="literal">Some</span>(<span class="keyword">ref</span> x) =&gt; traverse(x),</span><br><span class="line">        _ =&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消耗性遍历：</span></span><br><span class="line"><span class="comment">// fn traverse(tree: Tree) &#123;</span></span><br><span class="line"><span class="comment">//     println!(&quot;Node Value: &#123;:?&#125;&quot;, tree.value);</span></span><br><span class="line"><span class="comment">//     if tree.left.is_some() &#123;</span></span><br><span class="line"><span class="comment">//         traverse(*tree.left.unwrap()); // 手动解引用</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     if tree.right.is_some() &#123;</span></span><br><span class="line"><span class="comment">//         traverse(*tree.right.unwrap()); // 手动解引用</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;begin rust tree test:&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> tree = Tree &#123; value : <span class="number">12</span>, ..<span class="built_in">Default</span>::default() &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> left = Tree &#123; value : <span class="number">121</span>, ..<span class="built_in">Default</span>::default() &#125;;</span><br><span class="line">    tree.insert(&amp;<span class="built_in">String</span>::from(<span class="string">&quot;left&quot;</span>), left);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> right = Tree &#123; value : <span class="number">122</span>, ..<span class="built_in">Default</span>::default() &#125;;</span><br><span class="line">    tree.insert(&amp;<span class="built_in">String</span>::from(<span class="string">&quot;right&quot;</span>), right);</span><br><span class="line">    <span class="comment">// tree.delete(&amp;String::from(&quot;right&quot;));</span></span><br><span class="line">    <span class="comment">// println!(&quot;Tree val: &#123;:?&#125;&quot;, left.get_val()); 不能这样写，所有权已经被移动</span></span><br><span class="line">    traverse(&amp;tree);</span><br><span class="line">    <span class="comment">// traverse(tree);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Rust-简介&quot;&gt;&lt;a href=&quot;#Rust-简介&quot; class=&quot;headerlink&quot; title=&quot;Rust 简介&quot;&gt;&lt;/a&gt;Rust 简介&lt;/h3&gt;&lt;p&gt;实际上自己接触 Rust 的时间还是很有限的，这里也不会对 Rust 进行长篇大论地介绍，简单来说，</summary>
      
    
    
    
    
    <category term="Rust" scheme="https://z4ynadmin.github.io/tags/Rust/"/>
    
  </entry>
  
</feed>
